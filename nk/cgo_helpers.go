// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Thu, 14 Sep 2017 13:56:04 CEST.
// By https://git.io/c-for-go. DO NOT EDIT.

package nk

/*
#include "nuklear.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

func (x PluginAlloc) PassRef() (ref *C.nk_plugin_alloc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginAlloc88237AC9Func == nil {
		pluginAlloc88237AC9Func = x
	}
	return (*C.nk_plugin_alloc)(C.nk_plugin_alloc_88237ac9), nil
}

func (x PluginAlloc) PassValue() (ref C.nk_plugin_alloc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginAlloc88237AC9Func == nil {
		pluginAlloc88237AC9Func = x
	}
	return (C.nk_plugin_alloc)(C.nk_plugin_alloc_88237ac9), nil
}

func NewPluginAllocRef(ref unsafe.Pointer) *PluginAlloc {
	return (*PluginAlloc)(ref)
}

//export pluginAlloc88237AC9
func pluginAlloc88237AC9(carg0 C.nk_handle, cold unsafe.Pointer, carg2 C.nk_size) unsafe.Pointer {
	if pluginAlloc88237AC9Func != nil {
		arg088237ac9 := *(*Handle)(unsafe.Pointer(&carg0))
		old88237ac9 := (unsafe.Pointer)(unsafe.Pointer(cold))
		arg288237ac9 := (Size)(carg2)
		ret88237ac9 := pluginAlloc88237AC9Func(arg088237ac9, old88237ac9, arg288237ac9)
		ret, _ := ret88237ac9, cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pluginAlloc88237AC9Func PluginAlloc

func (x PluginFree) PassRef() (ref *C.nk_plugin_free, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginFree9E32BB09Func == nil {
		pluginFree9E32BB09Func = x
	}
	return (*C.nk_plugin_free)(C.nk_plugin_free_9e32bb09), nil
}

func (x PluginFree) PassValue() (ref C.nk_plugin_free, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginFree9E32BB09Func == nil {
		pluginFree9E32BB09Func = x
	}
	return (C.nk_plugin_free)(C.nk_plugin_free_9e32bb09), nil
}

func NewPluginFreeRef(ref unsafe.Pointer) *PluginFree {
	return (*PluginFree)(ref)
}

//export pluginFree9E32BB09
func pluginFree9E32BB09(carg0 C.nk_handle, cold unsafe.Pointer) {
	if pluginFree9E32BB09Func != nil {
		arg09e32bb09 := *(*Handle)(unsafe.Pointer(&carg0))
		old9e32bb09 := (unsafe.Pointer)(unsafe.Pointer(cold))
		pluginFree9E32BB09Func(arg09e32bb09, old9e32bb09)
		return
	}
	panic("callback func has not been set (race?)")
}

var pluginFree9E32BB09Func PluginFree

func (x PluginFilter) PassRef() (ref *C.nk_plugin_filter, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginFilter1DF5F22CFunc == nil {
		pluginFilter1DF5F22CFunc = x
	}
	return (*C.nk_plugin_filter)(C.nk_plugin_filter_1df5f22c), nil
}

func (x PluginFilter) PassValue() (ref C.nk_plugin_filter, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginFilter1DF5F22CFunc == nil {
		pluginFilter1DF5F22CFunc = x
	}
	return (C.nk_plugin_filter)(C.nk_plugin_filter_1df5f22c), nil
}

func NewPluginFilterRef(ref unsafe.Pointer) *PluginFilter {
	return (*PluginFilter)(ref)
}

//export pluginFilter1DF5F22C
func pluginFilter1DF5F22C(carg0 *C.struct_nk_text_edit, cunicode C.nk_rune) C.int {
	if pluginFilter1DF5F22CFunc != nil {
		arg01df5f22c := NewTextEditRef(unsafe.Pointer(carg0))
		unicode1df5f22c := (Rune)(cunicode)
		ret1df5f22c := pluginFilter1DF5F22CFunc(arg01df5f22c, unicode1df5f22c)
		ret, _ := (C.int)(ret1df5f22c), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var pluginFilter1DF5F22CFunc PluginFilter

func (x PluginPaste) PassRef() (ref *C.nk_plugin_paste, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginPaste70E696C4Func == nil {
		pluginPaste70E696C4Func = x
	}
	return (*C.nk_plugin_paste)(C.nk_plugin_paste_70e696c4), nil
}

func (x PluginPaste) PassValue() (ref C.nk_plugin_paste, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginPaste70E696C4Func == nil {
		pluginPaste70E696C4Func = x
	}
	return (C.nk_plugin_paste)(C.nk_plugin_paste_70e696c4), nil
}

func NewPluginPasteRef(ref unsafe.Pointer) *PluginPaste {
	return (*PluginPaste)(ref)
}

//export pluginPaste70E696C4
func pluginPaste70E696C4(carg0 C.nk_handle, carg1 *C.struct_nk_text_edit) {
	if pluginPaste70E696C4Func != nil {
		arg070e696c4 := *(*Handle)(unsafe.Pointer(&carg0))
		arg170e696c4 := NewTextEditRef(unsafe.Pointer(carg1))
		pluginPaste70E696C4Func(arg070e696c4, arg170e696c4)
		return
	}
	panic("callback func has not been set (race?)")
}

var pluginPaste70E696C4Func PluginPaste

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

func (x PluginCopy) PassRef() (ref *C.nk_plugin_copy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginCopy9EA6C143Func == nil {
		pluginCopy9EA6C143Func = x
	}
	return (*C.nk_plugin_copy)(C.nk_plugin_copy_9ea6c143), nil
}

func (x PluginCopy) PassValue() (ref C.nk_plugin_copy, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if pluginCopy9EA6C143Func == nil {
		pluginCopy9EA6C143Func = x
	}
	return (C.nk_plugin_copy)(C.nk_plugin_copy_9ea6c143), nil
}

func NewPluginCopyRef(ref unsafe.Pointer) *PluginCopy {
	return (*PluginCopy)(ref)
}

//export pluginCopy9EA6C143
func pluginCopy9EA6C143(carg0 C.nk_handle, carg1 *C.char, clen C.int) {
	if pluginCopy9EA6C143Func != nil {
		arg09ea6c143 := *(*Handle)(unsafe.Pointer(&carg0))
		arg19ea6c143 := packPCharString(carg1)
		len9ea6c143 := (int32)(clen)
		pluginCopy9EA6C143Func(arg09ea6c143, arg19ea6c143, len9ea6c143)
		return
	}
	panic("callback func has not been set (race?)")
}

var pluginCopy9EA6C143Func PluginCopy

func (x TextWidthF) PassRef() (ref *C.nk_text_width_f, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if textWidthF67477C0Func == nil {
		textWidthF67477C0Func = x
	}
	return (*C.nk_text_width_f)(C.nk_text_width_f_67477c0), nil
}

func (x TextWidthF) PassValue() (ref C.nk_text_width_f, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if textWidthF67477C0Func == nil {
		textWidthF67477C0Func = x
	}
	return (C.nk_text_width_f)(C.nk_text_width_f_67477c0), nil
}

func NewTextWidthFRef(ref unsafe.Pointer) *TextWidthF {
	return (*TextWidthF)(ref)
}

//export textWidthF67477C0
func textWidthF67477C0(carg0 C.nk_handle, ch C.float, carg2 *C.char, clen C.int) C.float {
	if textWidthF67477C0Func != nil {
		arg067477c0 := *(*Handle)(unsafe.Pointer(&carg0))
		h67477c0 := (float32)(ch)
		arg267477c0 := packPCharString(carg2)
		len67477c0 := (int32)(clen)
		ret67477c0 := textWidthF67477C0Func(arg067477c0, h67477c0, arg267477c0, len67477c0)
		ret, _ := (C.float)(ret67477c0), cgoAllocsUnknown
		return ret
	}
	panic("callback func has not been set (race?)")
}

var textWidthF67477C0Func TextWidthF

func (x QueryFontGlyphF) PassRef() (ref *C.nk_query_font_glyph_f, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if queryFontGlyphF5BA87240Func == nil {
		queryFontGlyphF5BA87240Func = x
	}
	return (*C.nk_query_font_glyph_f)(C.nk_query_font_glyph_f_5ba87240), nil
}

func (x QueryFontGlyphF) PassValue() (ref C.nk_query_font_glyph_f, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if queryFontGlyphF5BA87240Func == nil {
		queryFontGlyphF5BA87240Func = x
	}
	return (C.nk_query_font_glyph_f)(C.nk_query_font_glyph_f_5ba87240), nil
}

func NewQueryFontGlyphFRef(ref unsafe.Pointer) *QueryFontGlyphF {
	return (*QueryFontGlyphF)(ref)
}

//export queryFontGlyphF5BA87240
func queryFontGlyphF5BA87240(chandle C.nk_handle, cfontHeight C.float, cglyph *C.struct_nk_user_font_glyph, ccodepoint C.nk_rune, cnextCodepoint C.nk_rune) {
	if queryFontGlyphF5BA87240Func != nil {
		handle5ba87240 := *(*Handle)(unsafe.Pointer(&chandle))
		fontHeight5ba87240 := (float32)(cfontHeight)
		glyph5ba87240 := NewUserFontGlyphRef(unsafe.Pointer(cglyph))
		codepoint5ba87240 := (Rune)(ccodepoint)
		nextCodepoint5ba87240 := (Rune)(cnextCodepoint)
		queryFontGlyphF5BA87240Func(handle5ba87240, fontHeight5ba87240, glyph5ba87240, codepoint5ba87240, nextCodepoint5ba87240)
		return
	}
	panic("callback func has not been set (race?)")
}

var queryFontGlyphF5BA87240Func QueryFontGlyphF

func (x CommandCustomCallback) PassRef() (ref *C.nk_command_custom_callback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if commandCustomCallbackD451FDB1Func == nil {
		commandCustomCallbackD451FDB1Func = x
	}
	return (*C.nk_command_custom_callback)(C.nk_command_custom_callback_d451fdb1), nil
}

func (x CommandCustomCallback) PassValue() (ref C.nk_command_custom_callback, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if commandCustomCallbackD451FDB1Func == nil {
		commandCustomCallbackD451FDB1Func = x
	}
	return (C.nk_command_custom_callback)(C.nk_command_custom_callback_d451fdb1), nil
}

func NewCommandCustomCallbackRef(ref unsafe.Pointer) *CommandCustomCallback {
	return (*CommandCustomCallback)(ref)
}

//export commandCustomCallbackD451FDB1
func commandCustomCallbackD451FDB1(ccanvas unsafe.Pointer, cx C.short, cy C.short, cw C.ushort, ch C.ushort, ccallbackData C.nk_handle) {
	if commandCustomCallbackD451FDB1Func != nil {
		canvasd451fdb1 := (unsafe.Pointer)(unsafe.Pointer(ccanvas))
		xd451fdb1 := (int16)(cx)
		yd451fdb1 := (int16)(cy)
		wd451fdb1 := (uint16)(cw)
		hd451fdb1 := (uint16)(ch)
		callbackDatad451fdb1 := *(*Handle)(unsafe.Pointer(&ccallbackData))
		commandCustomCallbackD451FDB1Func(canvasd451fdb1, xd451fdb1, yd451fdb1, wd451fdb1, hd451fdb1, callbackDatad451fdb1)
		return
	}
	panic("callback func has not been set (race?)")
}

var commandCustomCallbackD451FDB1Func CommandCustomCallback

// Ref returns a reference to C object as it is.
func (x *Allocator) Ref() *C.struct_nk_allocator {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_allocator)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Allocator) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewAllocatorRef converts the C object reference into a raw struct reference without wrapping.
func NewAllocatorRef(ref unsafe.Pointer) *Allocator {
	return (*Allocator)(ref)
}

// NewAllocator allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewAllocator() *Allocator {
	return (*Allocator)(allocStructNkAllocatorMemory(1))
}

// allocStructNkAllocatorMemory allocates memory for type C.struct_nk_allocator in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkAllocatorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkAllocatorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkAllocatorValue = unsafe.Sizeof([1]C.struct_nk_allocator{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Allocator) PassRef() *C.struct_nk_allocator {
	if x == nil {
		x = (*Allocator)(allocStructNkAllocatorMemory(1))
	}
	return (*C.struct_nk_allocator)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *BakedFont) Ref() *C.struct_nk_baked_font {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_baked_font)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *BakedFont) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewBakedFontRef converts the C object reference into a raw struct reference without wrapping.
func NewBakedFontRef(ref unsafe.Pointer) *BakedFont {
	return (*BakedFont)(ref)
}

// NewBakedFont allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewBakedFont() *BakedFont {
	return (*BakedFont)(allocStructNkBakedFontMemory(1))
}

// allocStructNkBakedFontMemory allocates memory for type C.struct_nk_baked_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkBakedFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkBakedFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkBakedFontValue = unsafe.Sizeof([1]C.struct_nk_baked_font{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *BakedFont) PassRef() *C.struct_nk_baked_font {
	if x == nil {
		x = (*BakedFont)(allocStructNkBakedFontMemory(1))
	}
	return (*C.struct_nk_baked_font)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Buffer) Ref() *C.struct_nk_buffer {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_buffer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Buffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewBufferRef(ref unsafe.Pointer) *Buffer {
	return (*Buffer)(ref)
}

// NewBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewBuffer() *Buffer {
	return (*Buffer)(allocStructNkBufferMemory(1))
}

// allocStructNkBufferMemory allocates memory for type C.struct_nk_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkBufferValue = unsafe.Sizeof([1]C.struct_nk_buffer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Buffer) PassRef() *C.struct_nk_buffer {
	if x == nil {
		x = (*Buffer)(allocStructNkBufferMemory(1))
	}
	return (*C.struct_nk_buffer)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *BufferMarker) Ref() *C.struct_nk_buffer_marker {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_buffer_marker)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *BufferMarker) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewBufferMarkerRef converts the C object reference into a raw struct reference without wrapping.
func NewBufferMarkerRef(ref unsafe.Pointer) *BufferMarker {
	return (*BufferMarker)(ref)
}

// NewBufferMarker allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewBufferMarker() *BufferMarker {
	return (*BufferMarker)(allocStructNkBufferMarkerMemory(1))
}

// allocStructNkBufferMarkerMemory allocates memory for type C.struct_nk_buffer_marker in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkBufferMarkerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkBufferMarkerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkBufferMarkerValue = unsafe.Sizeof([1]C.struct_nk_buffer_marker{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *BufferMarker) PassRef() *C.struct_nk_buffer_marker {
	if x == nil {
		x = (*BufferMarker)(allocStructNkBufferMarkerMemory(1))
	}
	return (*C.struct_nk_buffer_marker)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Chart) Ref() *C.struct_nk_chart {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_chart)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Chart) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewChartRef converts the C object reference into a raw struct reference without wrapping.
func NewChartRef(ref unsafe.Pointer) *Chart {
	return (*Chart)(ref)
}

// NewChart allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewChart() *Chart {
	return (*Chart)(allocStructNkChartMemory(1))
}

// allocStructNkChartMemory allocates memory for type C.struct_nk_chart in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkChartMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkChartValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkChartValue = unsafe.Sizeof([1]C.struct_nk_chart{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Chart) PassRef() *C.struct_nk_chart {
	if x == nil {
		x = (*Chart)(allocStructNkChartMemory(1))
	}
	return (*C.struct_nk_chart)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ChartSlot) Ref() *C.struct_nk_chart_slot {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_chart_slot)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ChartSlot) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewChartSlotRef converts the C object reference into a raw struct reference without wrapping.
func NewChartSlotRef(ref unsafe.Pointer) *ChartSlot {
	return (*ChartSlot)(ref)
}

// NewChartSlot allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewChartSlot() *ChartSlot {
	return (*ChartSlot)(allocStructNkChartSlotMemory(1))
}

// allocStructNkChartSlotMemory allocates memory for type C.struct_nk_chart_slot in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkChartSlotMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkChartSlotValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkChartSlotValue = unsafe.Sizeof([1]C.struct_nk_chart_slot{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ChartSlot) PassRef() *C.struct_nk_chart_slot {
	if x == nil {
		x = (*ChartSlot)(allocStructNkChartSlotMemory(1))
	}
	return (*C.struct_nk_chart_slot)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Clipboard) Ref() *C.struct_nk_clipboard {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_clipboard)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Clipboard) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewClipboardRef converts the C object reference into a raw struct reference without wrapping.
func NewClipboardRef(ref unsafe.Pointer) *Clipboard {
	return (*Clipboard)(ref)
}

// NewClipboard allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewClipboard() *Clipboard {
	return (*Clipboard)(allocStructNkClipboardMemory(1))
}

// allocStructNkClipboardMemory allocates memory for type C.struct_nk_clipboard in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkClipboardMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkClipboardValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkClipboardValue = unsafe.Sizeof([1]C.struct_nk_clipboard{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Clipboard) PassRef() *C.struct_nk_clipboard {
	if x == nil {
		x = (*Clipboard)(allocStructNkClipboardMemory(1))
	}
	return (*C.struct_nk_clipboard)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Color) Ref() *C.struct_nk_color {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_color)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Color) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewColorRef converts the C object reference into a raw struct reference without wrapping.
func NewColorRef(ref unsafe.Pointer) *Color {
	return (*Color)(ref)
}

// NewColor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewColor() *Color {
	return (*Color)(allocStructNkColorMemory(1))
}

// allocStructNkColorMemory allocates memory for type C.struct_nk_color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkColorValue = unsafe.Sizeof([1]C.struct_nk_color{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Color) PassRef() *C.struct_nk_color {
	if x == nil {
		x = (*Color)(allocStructNkColorMemory(1))
	}
	return (*C.struct_nk_color)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Colorf) Ref() *C.struct_nk_colorf {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_colorf)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Colorf) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewColorfRef converts the C object reference into a raw struct reference without wrapping.
func NewColorfRef(ref unsafe.Pointer) *Colorf {
	return (*Colorf)(ref)
}

// NewColorf allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewColorf() *Colorf {
	return (*Colorf)(allocStructNkColorfMemory(1))
}

// allocStructNkColorfMemory allocates memory for type C.struct_nk_colorf in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkColorfMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkColorfValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkColorfValue = unsafe.Sizeof([1]C.struct_nk_colorf{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Colorf) PassRef() *C.struct_nk_colorf {
	if x == nil {
		x = (*Colorf)(allocStructNkColorfMemory(1))
	}
	return (*C.struct_nk_colorf)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Command) Ref() *C.struct_nk_command {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Command) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandRef(ref unsafe.Pointer) *Command {
	return (*Command)(ref)
}

// NewCommand allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommand() *Command {
	return (*Command)(allocStructNkCommandMemory(1))
}

// allocStructNkCommandMemory allocates memory for type C.struct_nk_command in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandValue = unsafe.Sizeof([1]C.struct_nk_command{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Command) PassRef() *C.struct_nk_command {
	if x == nil {
		x = (*Command)(allocStructNkCommandMemory(1))
	}
	return (*C.struct_nk_command)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandArc) Ref() *C.struct_nk_command_arc {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_arc)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandArc) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandArcRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandArcRef(ref unsafe.Pointer) *CommandArc {
	return (*CommandArc)(ref)
}

// NewCommandArc allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandArc() *CommandArc {
	return (*CommandArc)(allocStructNkCommandArcMemory(1))
}

// allocStructNkCommandArcMemory allocates memory for type C.struct_nk_command_arc in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandArcMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandArcValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandArcValue = unsafe.Sizeof([1]C.struct_nk_command_arc{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandArc) PassRef() *C.struct_nk_command_arc {
	if x == nil {
		x = (*CommandArc)(allocStructNkCommandArcMemory(1))
	}
	return (*C.struct_nk_command_arc)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandArcFilled) Ref() *C.struct_nk_command_arc_filled {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_arc_filled)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandArcFilled) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandArcFilledRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandArcFilledRef(ref unsafe.Pointer) *CommandArcFilled {
	return (*CommandArcFilled)(ref)
}

// NewCommandArcFilled allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandArcFilled() *CommandArcFilled {
	return (*CommandArcFilled)(allocStructNkCommandArcFilledMemory(1))
}

// allocStructNkCommandArcFilledMemory allocates memory for type C.struct_nk_command_arc_filled in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandArcFilledMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandArcFilledValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandArcFilledValue = unsafe.Sizeof([1]C.struct_nk_command_arc_filled{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandArcFilled) PassRef() *C.struct_nk_command_arc_filled {
	if x == nil {
		x = (*CommandArcFilled)(allocStructNkCommandArcFilledMemory(1))
	}
	return (*C.struct_nk_command_arc_filled)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandBuffer) Ref() *C.struct_nk_command_buffer {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_buffer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandBuffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandBufferRef(ref unsafe.Pointer) *CommandBuffer {
	return (*CommandBuffer)(ref)
}

// NewCommandBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandBuffer() *CommandBuffer {
	return (*CommandBuffer)(allocStructNkCommandBufferMemory(1))
}

// allocStructNkCommandBufferMemory allocates memory for type C.struct_nk_command_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandBufferValue = unsafe.Sizeof([1]C.struct_nk_command_buffer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandBuffer) PassRef() *C.struct_nk_command_buffer {
	if x == nil {
		x = (*CommandBuffer)(allocStructNkCommandBufferMemory(1))
	}
	return (*C.struct_nk_command_buffer)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandCircle) Ref() *C.struct_nk_command_circle {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_circle)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandCircle) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandCircleRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandCircleRef(ref unsafe.Pointer) *CommandCircle {
	return (*CommandCircle)(ref)
}

// NewCommandCircle allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandCircle() *CommandCircle {
	return (*CommandCircle)(allocStructNkCommandCircleMemory(1))
}

// allocStructNkCommandCircleMemory allocates memory for type C.struct_nk_command_circle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandCircleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandCircleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandCircleValue = unsafe.Sizeof([1]C.struct_nk_command_circle{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandCircle) PassRef() *C.struct_nk_command_circle {
	if x == nil {
		x = (*CommandCircle)(allocStructNkCommandCircleMemory(1))
	}
	return (*C.struct_nk_command_circle)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandCircleFilled) Ref() *C.struct_nk_command_circle_filled {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_circle_filled)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandCircleFilled) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandCircleFilledRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandCircleFilledRef(ref unsafe.Pointer) *CommandCircleFilled {
	return (*CommandCircleFilled)(ref)
}

// NewCommandCircleFilled allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandCircleFilled() *CommandCircleFilled {
	return (*CommandCircleFilled)(allocStructNkCommandCircleFilledMemory(1))
}

// allocStructNkCommandCircleFilledMemory allocates memory for type C.struct_nk_command_circle_filled in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandCircleFilledMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandCircleFilledValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandCircleFilledValue = unsafe.Sizeof([1]C.struct_nk_command_circle_filled{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandCircleFilled) PassRef() *C.struct_nk_command_circle_filled {
	if x == nil {
		x = (*CommandCircleFilled)(allocStructNkCommandCircleFilledMemory(1))
	}
	return (*C.struct_nk_command_circle_filled)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandCurve) Ref() *C.struct_nk_command_curve {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_curve)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandCurve) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandCurveRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandCurveRef(ref unsafe.Pointer) *CommandCurve {
	return (*CommandCurve)(ref)
}

// NewCommandCurve allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandCurve() *CommandCurve {
	return (*CommandCurve)(allocStructNkCommandCurveMemory(1))
}

// allocStructNkCommandCurveMemory allocates memory for type C.struct_nk_command_curve in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandCurveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandCurveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandCurveValue = unsafe.Sizeof([1]C.struct_nk_command_curve{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandCurve) PassRef() *C.struct_nk_command_curve {
	if x == nil {
		x = (*CommandCurve)(allocStructNkCommandCurveMemory(1))
	}
	return (*C.struct_nk_command_curve)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandCustom) Ref() *C.struct_nk_command_custom {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_custom)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandCustom) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandCustomRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandCustomRef(ref unsafe.Pointer) *CommandCustom {
	return (*CommandCustom)(ref)
}

// NewCommandCustom allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandCustom() *CommandCustom {
	return (*CommandCustom)(allocStructNkCommandCustomMemory(1))
}

// allocStructNkCommandCustomMemory allocates memory for type C.struct_nk_command_custom in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandCustomMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandCustomValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandCustomValue = unsafe.Sizeof([1]C.struct_nk_command_custom{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandCustom) PassRef() *C.struct_nk_command_custom {
	if x == nil {
		x = (*CommandCustom)(allocStructNkCommandCustomMemory(1))
	}
	return (*C.struct_nk_command_custom)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandImage) Ref() *C.struct_nk_command_image {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_image)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandImage) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandImageRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandImageRef(ref unsafe.Pointer) *CommandImage {
	return (*CommandImage)(ref)
}

// NewCommandImage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandImage() *CommandImage {
	return (*CommandImage)(allocStructNkCommandImageMemory(1))
}

// allocStructNkCommandImageMemory allocates memory for type C.struct_nk_command_image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandImageValue = unsafe.Sizeof([1]C.struct_nk_command_image{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandImage) PassRef() *C.struct_nk_command_image {
	if x == nil {
		x = (*CommandImage)(allocStructNkCommandImageMemory(1))
	}
	return (*C.struct_nk_command_image)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandLine) Ref() *C.struct_nk_command_line {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_line)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandLine) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandLineRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandLineRef(ref unsafe.Pointer) *CommandLine {
	return (*CommandLine)(ref)
}

// NewCommandLine allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandLine() *CommandLine {
	return (*CommandLine)(allocStructNkCommandLineMemory(1))
}

// allocStructNkCommandLineMemory allocates memory for type C.struct_nk_command_line in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandLineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandLineValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandLineValue = unsafe.Sizeof([1]C.struct_nk_command_line{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandLine) PassRef() *C.struct_nk_command_line {
	if x == nil {
		x = (*CommandLine)(allocStructNkCommandLineMemory(1))
	}
	return (*C.struct_nk_command_line)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandPolygon) Ref() *C.struct_nk_command_polygon {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_polygon)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandPolygon) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandPolygonRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandPolygonRef(ref unsafe.Pointer) *CommandPolygon {
	return (*CommandPolygon)(ref)
}

// NewCommandPolygon allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandPolygon() *CommandPolygon {
	return (*CommandPolygon)(allocStructNkCommandPolygonMemory(1))
}

// allocStructNkCommandPolygonMemory allocates memory for type C.struct_nk_command_polygon in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandPolygonMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandPolygonValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandPolygonValue = unsafe.Sizeof([1]C.struct_nk_command_polygon{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandPolygon) PassRef() *C.struct_nk_command_polygon {
	if x == nil {
		x = (*CommandPolygon)(allocStructNkCommandPolygonMemory(1))
	}
	return (*C.struct_nk_command_polygon)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandPolygonFilled) Ref() *C.struct_nk_command_polygon_filled {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_polygon_filled)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandPolygonFilled) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandPolygonFilledRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandPolygonFilledRef(ref unsafe.Pointer) *CommandPolygonFilled {
	return (*CommandPolygonFilled)(ref)
}

// NewCommandPolygonFilled allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandPolygonFilled() *CommandPolygonFilled {
	return (*CommandPolygonFilled)(allocStructNkCommandPolygonFilledMemory(1))
}

// allocStructNkCommandPolygonFilledMemory allocates memory for type C.struct_nk_command_polygon_filled in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandPolygonFilledMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandPolygonFilledValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandPolygonFilledValue = unsafe.Sizeof([1]C.struct_nk_command_polygon_filled{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandPolygonFilled) PassRef() *C.struct_nk_command_polygon_filled {
	if x == nil {
		x = (*CommandPolygonFilled)(allocStructNkCommandPolygonFilledMemory(1))
	}
	return (*C.struct_nk_command_polygon_filled)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandPolyline) Ref() *C.struct_nk_command_polyline {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_polyline)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandPolyline) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandPolylineRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandPolylineRef(ref unsafe.Pointer) *CommandPolyline {
	return (*CommandPolyline)(ref)
}

// NewCommandPolyline allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandPolyline() *CommandPolyline {
	return (*CommandPolyline)(allocStructNkCommandPolylineMemory(1))
}

// allocStructNkCommandPolylineMemory allocates memory for type C.struct_nk_command_polyline in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandPolylineMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandPolylineValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandPolylineValue = unsafe.Sizeof([1]C.struct_nk_command_polyline{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandPolyline) PassRef() *C.struct_nk_command_polyline {
	if x == nil {
		x = (*CommandPolyline)(allocStructNkCommandPolylineMemory(1))
	}
	return (*C.struct_nk_command_polyline)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandRect) Ref() *C.struct_nk_command_rect {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_rect)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandRect) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandRectRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandRectRef(ref unsafe.Pointer) *CommandRect {
	return (*CommandRect)(ref)
}

// NewCommandRect allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandRect() *CommandRect {
	return (*CommandRect)(allocStructNkCommandRectMemory(1))
}

// allocStructNkCommandRectMemory allocates memory for type C.struct_nk_command_rect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandRectValue = unsafe.Sizeof([1]C.struct_nk_command_rect{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandRect) PassRef() *C.struct_nk_command_rect {
	if x == nil {
		x = (*CommandRect)(allocStructNkCommandRectMemory(1))
	}
	return (*C.struct_nk_command_rect)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandRectFilled) Ref() *C.struct_nk_command_rect_filled {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_rect_filled)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandRectFilled) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandRectFilledRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandRectFilledRef(ref unsafe.Pointer) *CommandRectFilled {
	return (*CommandRectFilled)(ref)
}

// NewCommandRectFilled allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandRectFilled() *CommandRectFilled {
	return (*CommandRectFilled)(allocStructNkCommandRectFilledMemory(1))
}

// allocStructNkCommandRectFilledMemory allocates memory for type C.struct_nk_command_rect_filled in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandRectFilledMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandRectFilledValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandRectFilledValue = unsafe.Sizeof([1]C.struct_nk_command_rect_filled{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandRectFilled) PassRef() *C.struct_nk_command_rect_filled {
	if x == nil {
		x = (*CommandRectFilled)(allocStructNkCommandRectFilledMemory(1))
	}
	return (*C.struct_nk_command_rect_filled)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandRectMultiColor) Ref() *C.struct_nk_command_rect_multi_color {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_rect_multi_color)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandRectMultiColor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandRectMultiColorRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandRectMultiColorRef(ref unsafe.Pointer) *CommandRectMultiColor {
	return (*CommandRectMultiColor)(ref)
}

// NewCommandRectMultiColor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandRectMultiColor() *CommandRectMultiColor {
	return (*CommandRectMultiColor)(allocStructNkCommandRectMultiColorMemory(1))
}

// allocStructNkCommandRectMultiColorMemory allocates memory for type C.struct_nk_command_rect_multi_color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandRectMultiColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandRectMultiColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandRectMultiColorValue = unsafe.Sizeof([1]C.struct_nk_command_rect_multi_color{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandRectMultiColor) PassRef() *C.struct_nk_command_rect_multi_color {
	if x == nil {
		x = (*CommandRectMultiColor)(allocStructNkCommandRectMultiColorMemory(1))
	}
	return (*C.struct_nk_command_rect_multi_color)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandScissor) Ref() *C.struct_nk_command_scissor {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_scissor)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandScissor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandScissorRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandScissorRef(ref unsafe.Pointer) *CommandScissor {
	return (*CommandScissor)(ref)
}

// NewCommandScissor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandScissor() *CommandScissor {
	return (*CommandScissor)(allocStructNkCommandScissorMemory(1))
}

// allocStructNkCommandScissorMemory allocates memory for type C.struct_nk_command_scissor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandScissorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandScissorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandScissorValue = unsafe.Sizeof([1]C.struct_nk_command_scissor{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandScissor) PassRef() *C.struct_nk_command_scissor {
	if x == nil {
		x = (*CommandScissor)(allocStructNkCommandScissorMemory(1))
	}
	return (*C.struct_nk_command_scissor)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandText) Ref() *C.struct_nk_command_text {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_text)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandText) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandTextRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandTextRef(ref unsafe.Pointer) *CommandText {
	return (*CommandText)(ref)
}

// NewCommandText allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandText() *CommandText {
	return (*CommandText)(allocStructNkCommandTextMemory(1))
}

// allocStructNkCommandTextMemory allocates memory for type C.struct_nk_command_text in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandTextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandTextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandTextValue = unsafe.Sizeof([1]C.struct_nk_command_text{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandText) PassRef() *C.struct_nk_command_text {
	if x == nil {
		x = (*CommandText)(allocStructNkCommandTextMemory(1))
	}
	return (*C.struct_nk_command_text)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandTriangle) Ref() *C.struct_nk_command_triangle {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_triangle)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandTriangle) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandTriangleRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandTriangleRef(ref unsafe.Pointer) *CommandTriangle {
	return (*CommandTriangle)(ref)
}

// NewCommandTriangle allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandTriangle() *CommandTriangle {
	return (*CommandTriangle)(allocStructNkCommandTriangleMemory(1))
}

// allocStructNkCommandTriangleMemory allocates memory for type C.struct_nk_command_triangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandTriangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandTriangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandTriangleValue = unsafe.Sizeof([1]C.struct_nk_command_triangle{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandTriangle) PassRef() *C.struct_nk_command_triangle {
	if x == nil {
		x = (*CommandTriangle)(allocStructNkCommandTriangleMemory(1))
	}
	return (*C.struct_nk_command_triangle)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *CommandTriangleFilled) Ref() *C.struct_nk_command_triangle_filled {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_command_triangle_filled)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *CommandTriangleFilled) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCommandTriangleFilledRef converts the C object reference into a raw struct reference without wrapping.
func NewCommandTriangleFilledRef(ref unsafe.Pointer) *CommandTriangleFilled {
	return (*CommandTriangleFilled)(ref)
}

// NewCommandTriangleFilled allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCommandTriangleFilled() *CommandTriangleFilled {
	return (*CommandTriangleFilled)(allocStructNkCommandTriangleFilledMemory(1))
}

// allocStructNkCommandTriangleFilledMemory allocates memory for type C.struct_nk_command_triangle_filled in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCommandTriangleFilledMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCommandTriangleFilledValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCommandTriangleFilledValue = unsafe.Sizeof([1]C.struct_nk_command_triangle_filled{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *CommandTriangleFilled) PassRef() *C.struct_nk_command_triangle_filled {
	if x == nil {
		x = (*CommandTriangleFilled)(allocStructNkCommandTriangleFilledMemory(1))
	}
	return (*C.struct_nk_command_triangle_filled)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackButtonBehavior) Ref() *C.struct_nk_config_stack_button_behavior {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_button_behavior)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackButtonBehavior) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackButtonBehaviorRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackButtonBehaviorRef(ref unsafe.Pointer) *ConfigStackButtonBehavior {
	return (*ConfigStackButtonBehavior)(ref)
}

// NewConfigStackButtonBehavior allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackButtonBehavior() *ConfigStackButtonBehavior {
	return (*ConfigStackButtonBehavior)(allocStructNkConfigStackButtonBehaviorMemory(1))
}

// allocStructNkConfigStackButtonBehaviorMemory allocates memory for type C.struct_nk_config_stack_button_behavior in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackButtonBehaviorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackButtonBehaviorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackButtonBehaviorValue = unsafe.Sizeof([1]C.struct_nk_config_stack_button_behavior{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackButtonBehavior) PassRef() *C.struct_nk_config_stack_button_behavior {
	if x == nil {
		x = (*ConfigStackButtonBehavior)(allocStructNkConfigStackButtonBehaviorMemory(1))
	}
	return (*C.struct_nk_config_stack_button_behavior)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackButtonBehaviorElement) Ref() *C.struct_nk_config_stack_button_behavior_element {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_button_behavior_element)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackButtonBehaviorElement) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackButtonBehaviorElementRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackButtonBehaviorElementRef(ref unsafe.Pointer) *ConfigStackButtonBehaviorElement {
	return (*ConfigStackButtonBehaviorElement)(ref)
}

// NewConfigStackButtonBehaviorElement allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackButtonBehaviorElement() *ConfigStackButtonBehaviorElement {
	return (*ConfigStackButtonBehaviorElement)(allocStructNkConfigStackButtonBehaviorElementMemory(1))
}

// allocStructNkConfigStackButtonBehaviorElementMemory allocates memory for type C.struct_nk_config_stack_button_behavior_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackButtonBehaviorElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackButtonBehaviorElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackButtonBehaviorElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_button_behavior_element{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackButtonBehaviorElement) PassRef() *C.struct_nk_config_stack_button_behavior_element {
	if x == nil {
		x = (*ConfigStackButtonBehaviorElement)(allocStructNkConfigStackButtonBehaviorElementMemory(1))
	}
	return (*C.struct_nk_config_stack_button_behavior_element)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackColor) Ref() *C.struct_nk_config_stack_color {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_color)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackColor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackColorRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackColorRef(ref unsafe.Pointer) *ConfigStackColor {
	return (*ConfigStackColor)(ref)
}

// NewConfigStackColor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackColor() *ConfigStackColor {
	return (*ConfigStackColor)(allocStructNkConfigStackColorMemory(1))
}

// allocStructNkConfigStackColorMemory allocates memory for type C.struct_nk_config_stack_color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackColorValue = unsafe.Sizeof([1]C.struct_nk_config_stack_color{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackColor) PassRef() *C.struct_nk_config_stack_color {
	if x == nil {
		x = (*ConfigStackColor)(allocStructNkConfigStackColorMemory(1))
	}
	return (*C.struct_nk_config_stack_color)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackColorElement) Ref() *C.struct_nk_config_stack_color_element {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_color_element)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackColorElement) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackColorElementRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackColorElementRef(ref unsafe.Pointer) *ConfigStackColorElement {
	return (*ConfigStackColorElement)(ref)
}

// NewConfigStackColorElement allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackColorElement() *ConfigStackColorElement {
	return (*ConfigStackColorElement)(allocStructNkConfigStackColorElementMemory(1))
}

// allocStructNkConfigStackColorElementMemory allocates memory for type C.struct_nk_config_stack_color_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackColorElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackColorElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackColorElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_color_element{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackColorElement) PassRef() *C.struct_nk_config_stack_color_element {
	if x == nil {
		x = (*ConfigStackColorElement)(allocStructNkConfigStackColorElementMemory(1))
	}
	return (*C.struct_nk_config_stack_color_element)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackFlags) Ref() *C.struct_nk_config_stack_flags {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_flags)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackFlags) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackFlagsRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackFlagsRef(ref unsafe.Pointer) *ConfigStackFlags {
	return (*ConfigStackFlags)(ref)
}

// NewConfigStackFlags allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackFlags() *ConfigStackFlags {
	return (*ConfigStackFlags)(allocStructNkConfigStackFlagsMemory(1))
}

// allocStructNkConfigStackFlagsMemory allocates memory for type C.struct_nk_config_stack_flags in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackFlagsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackFlagsValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackFlagsValue = unsafe.Sizeof([1]C.struct_nk_config_stack_flags{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackFlags) PassRef() *C.struct_nk_config_stack_flags {
	if x == nil {
		x = (*ConfigStackFlags)(allocStructNkConfigStackFlagsMemory(1))
	}
	return (*C.struct_nk_config_stack_flags)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackFlagsElement) Ref() *C.struct_nk_config_stack_flags_element {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_flags_element)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackFlagsElement) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackFlagsElementRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackFlagsElementRef(ref unsafe.Pointer) *ConfigStackFlagsElement {
	return (*ConfigStackFlagsElement)(ref)
}

// NewConfigStackFlagsElement allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackFlagsElement() *ConfigStackFlagsElement {
	return (*ConfigStackFlagsElement)(allocStructNkConfigStackFlagsElementMemory(1))
}

// allocStructNkConfigStackFlagsElementMemory allocates memory for type C.struct_nk_config_stack_flags_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackFlagsElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackFlagsElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackFlagsElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_flags_element{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackFlagsElement) PassRef() *C.struct_nk_config_stack_flags_element {
	if x == nil {
		x = (*ConfigStackFlagsElement)(allocStructNkConfigStackFlagsElementMemory(1))
	}
	return (*C.struct_nk_config_stack_flags_element)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackFloat) Ref() *C.struct_nk_config_stack_float {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_float)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackFloat) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackFloatRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackFloatRef(ref unsafe.Pointer) *ConfigStackFloat {
	return (*ConfigStackFloat)(ref)
}

// NewConfigStackFloat allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackFloat() *ConfigStackFloat {
	return (*ConfigStackFloat)(allocStructNkConfigStackFloatMemory(1))
}

// allocStructNkConfigStackFloatMemory allocates memory for type C.struct_nk_config_stack_float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackFloatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackFloatValue = unsafe.Sizeof([1]C.struct_nk_config_stack_float{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackFloat) PassRef() *C.struct_nk_config_stack_float {
	if x == nil {
		x = (*ConfigStackFloat)(allocStructNkConfigStackFloatMemory(1))
	}
	return (*C.struct_nk_config_stack_float)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackFloatElement) Ref() *C.struct_nk_config_stack_float_element {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_float_element)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackFloatElement) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackFloatElementRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackFloatElementRef(ref unsafe.Pointer) *ConfigStackFloatElement {
	return (*ConfigStackFloatElement)(ref)
}

// NewConfigStackFloatElement allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackFloatElement() *ConfigStackFloatElement {
	return (*ConfigStackFloatElement)(allocStructNkConfigStackFloatElementMemory(1))
}

// allocStructNkConfigStackFloatElementMemory allocates memory for type C.struct_nk_config_stack_float_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackFloatElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackFloatElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackFloatElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_float_element{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackFloatElement) PassRef() *C.struct_nk_config_stack_float_element {
	if x == nil {
		x = (*ConfigStackFloatElement)(allocStructNkConfigStackFloatElementMemory(1))
	}
	return (*C.struct_nk_config_stack_float_element)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackStyleItem) Ref() *C.struct_nk_config_stack_style_item {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_style_item)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackStyleItem) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackStyleItemRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackStyleItemRef(ref unsafe.Pointer) *ConfigStackStyleItem {
	return (*ConfigStackStyleItem)(ref)
}

// NewConfigStackStyleItem allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackStyleItem() *ConfigStackStyleItem {
	return (*ConfigStackStyleItem)(allocStructNkConfigStackStyleItemMemory(1))
}

// allocStructNkConfigStackStyleItemMemory allocates memory for type C.struct_nk_config_stack_style_item in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackStyleItemMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackStyleItemValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackStyleItemValue = unsafe.Sizeof([1]C.struct_nk_config_stack_style_item{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackStyleItem) PassRef() *C.struct_nk_config_stack_style_item {
	if x == nil {
		x = (*ConfigStackStyleItem)(allocStructNkConfigStackStyleItemMemory(1))
	}
	return (*C.struct_nk_config_stack_style_item)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackStyleItemElement) Ref() *C.struct_nk_config_stack_style_item_element {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_style_item_element)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackStyleItemElement) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackStyleItemElementRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackStyleItemElementRef(ref unsafe.Pointer) *ConfigStackStyleItemElement {
	return (*ConfigStackStyleItemElement)(ref)
}

// NewConfigStackStyleItemElement allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackStyleItemElement() *ConfigStackStyleItemElement {
	return (*ConfigStackStyleItemElement)(allocStructNkConfigStackStyleItemElementMemory(1))
}

// allocStructNkConfigStackStyleItemElementMemory allocates memory for type C.struct_nk_config_stack_style_item_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackStyleItemElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackStyleItemElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackStyleItemElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_style_item_element{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackStyleItemElement) PassRef() *C.struct_nk_config_stack_style_item_element {
	if x == nil {
		x = (*ConfigStackStyleItemElement)(allocStructNkConfigStackStyleItemElementMemory(1))
	}
	return (*C.struct_nk_config_stack_style_item_element)(unsafe.Pointer(x))
}

// allocStructNkConfigStackUserFontMemory allocates memory for type C.struct_nk_config_stack_user_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackUserFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackUserFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackUserFontValue = unsafe.Sizeof([1]C.struct_nk_config_stack_user_font{})

// allocA8StructNkConfigStackUserFontElementMemory allocates memory for type [8]C.struct_nk_config_stack_user_font_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA8StructNkConfigStackUserFontElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA8StructNkConfigStackUserFontElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA8StructNkConfigStackUserFontElementValue = unsafe.Sizeof([1][8]C.struct_nk_config_stack_user_font_element{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackA8ConfigStackUserFontElement transforms a sliced Go data structure into plain C format.
func unpackA8ConfigStackUserFontElement(x [8]ConfigStackUserFontElement) (unpacked [8]C.struct_nk_config_stack_user_font_element, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[8]C.struct_nk_config_stack_user_font_element) {
		go allocs.Free()
	})

	mem0 := allocA8StructNkConfigStackUserFontElementMemory(1)
	allocs.Add(mem0)
	v0 := (*[8]C.struct_nk_config_stack_user_font_element)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[8]C.struct_nk_config_stack_user_font_element)(mem0)
	return
}

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// packA8ConfigStackUserFontElement reads sliced Go data structure out from plain C format.
func packA8ConfigStackUserFontElement(v *[8]ConfigStackUserFontElement, ptr0 *[8]C.struct_nk_config_stack_user_font_element) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewConfigStackUserFontElementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackUserFont) Ref() *C.struct_nk_config_stack_user_font {
	if x == nil {
		return nil
	}
	return x.refa664861d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackUserFont) Free() {
	if x != nil && x.allocsa664861d != nil {
		x.allocsa664861d.(*cgoAllocMap).Free()
		x.refa664861d = nil
	}
}

// NewConfigStackUserFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackUserFontRef(ref unsafe.Pointer) *ConfigStackUserFont {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackUserFont)
	obj.refa664861d = (*C.struct_nk_config_stack_user_font)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackUserFont) PassRef() (*C.struct_nk_config_stack_user_font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa664861d != nil {
		return x.refa664861d, nil
	}
	mema664861d := allocStructNkConfigStackUserFontMemory(1)
	refa664861d := (*C.struct_nk_config_stack_user_font)(mema664861d)
	allocsa664861d := new(cgoAllocMap)
	allocsa664861d.Add(mema664861d)

	var chead_allocs *cgoAllocMap
	refa664861d.head, chead_allocs = (C.int)(x.Head), cgoAllocsUnknown
	allocsa664861d.Borrow(chead_allocs)

	var celements_allocs *cgoAllocMap
	refa664861d.elements, celements_allocs = unpackA8ConfigStackUserFontElement(x.Elements)
	allocsa664861d.Borrow(celements_allocs)

	x.refa664861d = refa664861d
	x.allocsa664861d = allocsa664861d
	return refa664861d, allocsa664861d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackUserFont) PassValue() (C.struct_nk_config_stack_user_font, *cgoAllocMap) {
	if x.refa664861d != nil {
		return *x.refa664861d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackUserFont) Deref() {
	if x.refa664861d == nil {
		return
	}
	x.Head = (int32)(x.refa664861d.head)
	packA8ConfigStackUserFontElement(&x.Elements, (*[8]C.struct_nk_config_stack_user_font_element)(unsafe.Pointer(&x.refa664861d.elements)))
}

// allocStructNkConfigStackUserFontElementMemory allocates memory for type C.struct_nk_config_stack_user_font_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackUserFontElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackUserFontElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackUserFontElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_user_font_element{})

// allocPStructNkUserFontMemory allocates memory for type *C.struct_nk_user_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPStructNkUserFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPStructNkUserFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPStructNkUserFontValue = unsafe.Sizeof([1]*C.struct_nk_user_font{})

// allocStructNkUserFontMemory allocates memory for type C.struct_nk_user_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkUserFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkUserFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkUserFontValue = unsafe.Sizeof([1]C.struct_nk_user_font{})

// unpackSSUserFont transforms a sliced Go data structure into plain C format.
func unpackSSUserFont(x [][]UserFont) (unpacked **C.struct_nk_user_font, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.struct_nk_user_font) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPStructNkUserFontMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.struct_nk_user_font)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocStructNkUserFontMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: uintptr(mem1),
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.struct_nk_user_font)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.struct_nk_user_font)(unsafe.Pointer(h.Data))
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.struct_nk_user_font)(unsafe.Pointer(h.Data))
	return
}

// unpackSUserFont transforms a sliced Go data structure into plain C format.
func unpackSUserFont(x []UserFont) (unpacked *C.struct_nk_user_font, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_user_font) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkUserFontMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_user_font)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_user_font)(unsafe.Pointer(h.Data))
	return
}

// packSSUserFont reads sliced Go data structure out from plain C format.
func packSSUserFont(v [][]UserFont, ptr0 **C.struct_nk_user_font) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.struct_nk_user_font)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfStructNkUserFontValue]C.struct_nk_user_font)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewUserFontRef(unsafe.Pointer(&ptr2))
		}
	}
}

// packSUserFont reads sliced Go data structure out from plain C format.
func packSUserFont(v []UserFont, ptr0 *C.struct_nk_user_font) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkUserFontValue]C.struct_nk_user_font)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewUserFontRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfigStackUserFontElement) Ref() *C.struct_nk_config_stack_user_font_element {
	if x == nil {
		return nil
	}
	return x.ref5572630c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfigStackUserFontElement) Free() {
	if x != nil && x.allocs5572630c != nil {
		x.allocs5572630c.(*cgoAllocMap).Free()
		x.ref5572630c = nil
	}
}

// NewConfigStackUserFontElementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfigStackUserFontElementRef(ref unsafe.Pointer) *ConfigStackUserFontElement {
	if ref == nil {
		return nil
	}
	obj := new(ConfigStackUserFontElement)
	obj.ref5572630c = (*C.struct_nk_config_stack_user_font_element)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfigStackUserFontElement) PassRef() (*C.struct_nk_config_stack_user_font_element, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5572630c != nil {
		return x.ref5572630c, nil
	}
	mem5572630c := allocStructNkConfigStackUserFontElementMemory(1)
	ref5572630c := (*C.struct_nk_config_stack_user_font_element)(mem5572630c)
	allocs5572630c := new(cgoAllocMap)
	allocs5572630c.Add(mem5572630c)

	var caddress_allocs *cgoAllocMap
	ref5572630c.address, caddress_allocs = unpackSSUserFont(x.Address)
	allocs5572630c.Borrow(caddress_allocs)

	var cold_value_allocs *cgoAllocMap
	ref5572630c.old_value, cold_value_allocs = unpackSUserFont(x.OldValue)
	allocs5572630c.Borrow(cold_value_allocs)

	x.ref5572630c = ref5572630c
	x.allocs5572630c = allocs5572630c
	return ref5572630c, allocs5572630c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfigStackUserFontElement) PassValue() (C.struct_nk_config_stack_user_font_element, *cgoAllocMap) {
	if x.ref5572630c != nil {
		return *x.ref5572630c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfigStackUserFontElement) Deref() {
	if x.ref5572630c == nil {
		return
	}
	packSSUserFont(x.Address, x.ref5572630c.address)
	packSUserFont(x.OldValue, x.ref5572630c.old_value)
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackVec2) Ref() *C.struct_nk_config_stack_vec2 {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_vec2)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackVec2) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackVec2Ref converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackVec2Ref(ref unsafe.Pointer) *ConfigStackVec2 {
	return (*ConfigStackVec2)(ref)
}

// NewConfigStackVec2 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackVec2() *ConfigStackVec2 {
	return (*ConfigStackVec2)(allocStructNkConfigStackVec2Memory(1))
}

// allocStructNkConfigStackVec2Memory allocates memory for type C.struct_nk_config_stack_vec2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackVec2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackVec2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackVec2Value = unsafe.Sizeof([1]C.struct_nk_config_stack_vec2{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackVec2) PassRef() *C.struct_nk_config_stack_vec2 {
	if x == nil {
		x = (*ConfigStackVec2)(allocStructNkConfigStackVec2Memory(1))
	}
	return (*C.struct_nk_config_stack_vec2)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigStackVec2Element) Ref() *C.struct_nk_config_stack_vec2_element {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_config_stack_vec2_element)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigStackVec2Element) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigStackVec2ElementRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigStackVec2ElementRef(ref unsafe.Pointer) *ConfigStackVec2Element {
	return (*ConfigStackVec2Element)(ref)
}

// NewConfigStackVec2Element allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigStackVec2Element() *ConfigStackVec2Element {
	return (*ConfigStackVec2Element)(allocStructNkConfigStackVec2ElementMemory(1))
}

// allocStructNkConfigStackVec2ElementMemory allocates memory for type C.struct_nk_config_stack_vec2_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigStackVec2ElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigStackVec2ElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigStackVec2ElementValue = unsafe.Sizeof([1]C.struct_nk_config_stack_vec2_element{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigStackVec2Element) PassRef() *C.struct_nk_config_stack_vec2_element {
	if x == nil {
		x = (*ConfigStackVec2Element)(allocStructNkConfigStackVec2ElementMemory(1))
	}
	return (*C.struct_nk_config_stack_vec2_element)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ConfigurationStacks) Ref() *C.struct_nk_configuration_stacks {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_configuration_stacks)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ConfigurationStacks) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewConfigurationStacksRef converts the C object reference into a raw struct reference without wrapping.
func NewConfigurationStacksRef(ref unsafe.Pointer) *ConfigurationStacks {
	return (*ConfigurationStacks)(ref)
}

// NewConfigurationStacks allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewConfigurationStacks() *ConfigurationStacks {
	return (*ConfigurationStacks)(allocStructNkConfigurationStacksMemory(1))
}

// allocStructNkConfigurationStacksMemory allocates memory for type C.struct_nk_configuration_stacks in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConfigurationStacksMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConfigurationStacksValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConfigurationStacksValue = unsafe.Sizeof([1]C.struct_nk_configuration_stacks{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ConfigurationStacks) PassRef() *C.struct_nk_configuration_stacks {
	if x == nil {
		x = (*ConfigurationStacks)(allocStructNkConfigurationStacksMemory(1))
	}
	return (*C.struct_nk_configuration_stacks)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Context) Ref() *C.struct_nk_context {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_context)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Context) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewContextRef converts the C object reference into a raw struct reference without wrapping.
func NewContextRef(ref unsafe.Pointer) *Context {
	return (*Context)(ref)
}

// NewContext allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewContext() *Context {
	return (*Context)(allocStructNkContextMemory(1))
}

// allocStructNkContextMemory allocates memory for type C.struct_nk_context in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkContextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkContextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkContextValue = unsafe.Sizeof([1]C.struct_nk_context{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Context) PassRef() *C.struct_nk_context {
	if x == nil {
		x = (*Context)(allocStructNkContextMemory(1))
	}
	return (*C.struct_nk_context)(unsafe.Pointer(x))
}

// allocStructNkConvertConfigMemory allocates memory for type C.struct_nk_convert_config in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkConvertConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkConvertConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkConvertConfigValue = unsafe.Sizeof([1]C.struct_nk_convert_config{})

// allocStructNkDrawVertexLayoutElementMemory allocates memory for type C.struct_nk_draw_vertex_layout_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkDrawVertexLayoutElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkDrawVertexLayoutElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkDrawVertexLayoutElementValue = unsafe.Sizeof([1]C.struct_nk_draw_vertex_layout_element{})

// unpackSDrawVertexLayoutElement transforms a sliced Go data structure into plain C format.
func unpackSDrawVertexLayoutElement(x []DrawVertexLayoutElement) (unpacked *C.struct_nk_draw_vertex_layout_element, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_draw_vertex_layout_element) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkDrawVertexLayoutElementMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_draw_vertex_layout_element)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_draw_vertex_layout_element)(unsafe.Pointer(h.Data))
	return
}

// packSDrawVertexLayoutElement reads sliced Go data structure out from plain C format.
func packSDrawVertexLayoutElement(v []DrawVertexLayoutElement, ptr0 *C.struct_nk_draw_vertex_layout_element) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfStructNkDrawVertexLayoutElementValue]C.struct_nk_draw_vertex_layout_element)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewDrawVertexLayoutElementRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConvertConfig) Ref() *C.struct_nk_convert_config {
	if x == nil {
		return nil
	}
	return x.ref82bf4c25
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConvertConfig) Free() {
	if x != nil && x.allocs82bf4c25 != nil {
		x.allocs82bf4c25.(*cgoAllocMap).Free()
		x.ref82bf4c25 = nil
	}
}

// NewConvertConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConvertConfigRef(ref unsafe.Pointer) *ConvertConfig {
	if ref == nil {
		return nil
	}
	obj := new(ConvertConfig)
	obj.ref82bf4c25 = (*C.struct_nk_convert_config)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConvertConfig) PassRef() (*C.struct_nk_convert_config, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref82bf4c25 != nil {
		return x.ref82bf4c25, nil
	}
	mem82bf4c25 := allocStructNkConvertConfigMemory(1)
	ref82bf4c25 := (*C.struct_nk_convert_config)(mem82bf4c25)
	allocs82bf4c25 := new(cgoAllocMap)
	allocs82bf4c25.Add(mem82bf4c25)

	var cglobal_alpha_allocs *cgoAllocMap
	ref82bf4c25.global_alpha, cglobal_alpha_allocs = (C.float)(x.GlobalAlpha), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cglobal_alpha_allocs)

	var cline_AA_allocs *cgoAllocMap
	ref82bf4c25.line_AA, cline_AA_allocs = (C.enum_nk_anti_aliasing)(x.LineAa), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cline_AA_allocs)

	var cshape_AA_allocs *cgoAllocMap
	ref82bf4c25.shape_AA, cshape_AA_allocs = (C.enum_nk_anti_aliasing)(x.ShapeAa), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cshape_AA_allocs)

	var ccircle_segment_count_allocs *cgoAllocMap
	ref82bf4c25.circle_segment_count, ccircle_segment_count_allocs = (C.uint)(x.CircleSegmentCount), cgoAllocsUnknown
	allocs82bf4c25.Borrow(ccircle_segment_count_allocs)

	var carc_segment_count_allocs *cgoAllocMap
	ref82bf4c25.arc_segment_count, carc_segment_count_allocs = (C.uint)(x.ArcSegmentCount), cgoAllocsUnknown
	allocs82bf4c25.Borrow(carc_segment_count_allocs)

	var ccurve_segment_count_allocs *cgoAllocMap
	ref82bf4c25.curve_segment_count, ccurve_segment_count_allocs = (C.uint)(x.CurveSegmentCount), cgoAllocsUnknown
	allocs82bf4c25.Borrow(ccurve_segment_count_allocs)

	var cnull_allocs *cgoAllocMap
	ref82bf4c25.null, cnull_allocs = *(*C.struct_nk_draw_null_texture)(unsafe.Pointer(&x.Null)), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cnull_allocs)

	var cvertex_layout_allocs *cgoAllocMap
	ref82bf4c25.vertex_layout, cvertex_layout_allocs = unpackSDrawVertexLayoutElement(x.VertexLayout)
	allocs82bf4c25.Borrow(cvertex_layout_allocs)

	var cvertex_size_allocs *cgoAllocMap
	ref82bf4c25.vertex_size, cvertex_size_allocs = (C.nk_size)(x.VertexSize), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cvertex_size_allocs)

	var cvertex_alignment_allocs *cgoAllocMap
	ref82bf4c25.vertex_alignment, cvertex_alignment_allocs = (C.nk_size)(x.VertexAlignment), cgoAllocsUnknown
	allocs82bf4c25.Borrow(cvertex_alignment_allocs)

	x.ref82bf4c25 = ref82bf4c25
	x.allocs82bf4c25 = allocs82bf4c25
	return ref82bf4c25, allocs82bf4c25

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConvertConfig) PassValue() (C.struct_nk_convert_config, *cgoAllocMap) {
	if x.ref82bf4c25 != nil {
		return *x.ref82bf4c25, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConvertConfig) Deref() {
	if x.ref82bf4c25 == nil {
		return
	}
	x.GlobalAlpha = (float32)(x.ref82bf4c25.global_alpha)
	x.LineAa = (AntiAliasing)(x.ref82bf4c25.line_AA)
	x.ShapeAa = (AntiAliasing)(x.ref82bf4c25.shape_AA)
	x.CircleSegmentCount = (uint32)(x.ref82bf4c25.circle_segment_count)
	x.ArcSegmentCount = (uint32)(x.ref82bf4c25.arc_segment_count)
	x.CurveSegmentCount = (uint32)(x.ref82bf4c25.curve_segment_count)
	x.Null = *(*DrawNullTexture)(unsafe.Pointer(&x.ref82bf4c25.null))
	packSDrawVertexLayoutElement(x.VertexLayout, x.ref82bf4c25.vertex_layout)
	x.VertexSize = (Size)(x.ref82bf4c25.vertex_size)
	x.VertexAlignment = (Size)(x.ref82bf4c25.vertex_alignment)
}

// Ref returns a reference to C object as it is.
func (x *Cursor) Ref() *C.struct_nk_cursor {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_cursor)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Cursor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCursorRef converts the C object reference into a raw struct reference without wrapping.
func NewCursorRef(ref unsafe.Pointer) *Cursor {
	return (*Cursor)(ref)
}

// NewCursor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCursor() *Cursor {
	return (*Cursor)(allocStructNkCursorMemory(1))
}

// allocStructNkCursorMemory allocates memory for type C.struct_nk_cursor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkCursorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkCursorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkCursorValue = unsafe.Sizeof([1]C.struct_nk_cursor{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Cursor) PassRef() *C.struct_nk_cursor {
	if x == nil {
		x = (*Cursor)(allocStructNkCursorMemory(1))
	}
	return (*C.struct_nk_cursor)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DrawCommand) Ref() *C.struct_nk_draw_command {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_draw_command)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DrawCommand) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDrawCommandRef converts the C object reference into a raw struct reference without wrapping.
func NewDrawCommandRef(ref unsafe.Pointer) *DrawCommand {
	return (*DrawCommand)(ref)
}

// NewDrawCommand allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDrawCommand() *DrawCommand {
	return (*DrawCommand)(allocStructNkDrawCommandMemory(1))
}

// allocStructNkDrawCommandMemory allocates memory for type C.struct_nk_draw_command in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkDrawCommandMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkDrawCommandValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkDrawCommandValue = unsafe.Sizeof([1]C.struct_nk_draw_command{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DrawCommand) PassRef() *C.struct_nk_draw_command {
	if x == nil {
		x = (*DrawCommand)(allocStructNkDrawCommandMemory(1))
	}
	return (*C.struct_nk_draw_command)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DrawList) Ref() *C.struct_nk_draw_list {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_draw_list)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DrawList) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDrawListRef converts the C object reference into a raw struct reference without wrapping.
func NewDrawListRef(ref unsafe.Pointer) *DrawList {
	return (*DrawList)(ref)
}

// NewDrawList allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDrawList() *DrawList {
	return (*DrawList)(allocStructNkDrawListMemory(1))
}

// allocStructNkDrawListMemory allocates memory for type C.struct_nk_draw_list in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkDrawListMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkDrawListValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkDrawListValue = unsafe.Sizeof([1]C.struct_nk_draw_list{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DrawList) PassRef() *C.struct_nk_draw_list {
	if x == nil {
		x = (*DrawList)(allocStructNkDrawListMemory(1))
	}
	return (*C.struct_nk_draw_list)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *DrawNullTexture) Ref() *C.struct_nk_draw_null_texture {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_draw_null_texture)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *DrawNullTexture) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewDrawNullTextureRef converts the C object reference into a raw struct reference without wrapping.
func NewDrawNullTextureRef(ref unsafe.Pointer) *DrawNullTexture {
	return (*DrawNullTexture)(ref)
}

// NewDrawNullTexture allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewDrawNullTexture() *DrawNullTexture {
	return (*DrawNullTexture)(allocStructNkDrawNullTextureMemory(1))
}

// allocStructNkDrawNullTextureMemory allocates memory for type C.struct_nk_draw_null_texture in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkDrawNullTextureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkDrawNullTextureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkDrawNullTextureValue = unsafe.Sizeof([1]C.struct_nk_draw_null_texture{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *DrawNullTexture) PassRef() *C.struct_nk_draw_null_texture {
	if x == nil {
		x = (*DrawNullTexture)(allocStructNkDrawNullTextureMemory(1))
	}
	return (*C.struct_nk_draw_null_texture)(unsafe.Pointer(x))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DrawVertexLayoutElement) Ref() *C.struct_nk_draw_vertex_layout_element {
	if x == nil {
		return nil
	}
	return x.refeb0614d6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DrawVertexLayoutElement) Free() {
	if x != nil && x.allocseb0614d6 != nil {
		x.allocseb0614d6.(*cgoAllocMap).Free()
		x.refeb0614d6 = nil
	}
}

// NewDrawVertexLayoutElementRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDrawVertexLayoutElementRef(ref unsafe.Pointer) *DrawVertexLayoutElement {
	if ref == nil {
		return nil
	}
	obj := new(DrawVertexLayoutElement)
	obj.refeb0614d6 = (*C.struct_nk_draw_vertex_layout_element)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DrawVertexLayoutElement) PassRef() (*C.struct_nk_draw_vertex_layout_element, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeb0614d6 != nil {
		return x.refeb0614d6, nil
	}
	memeb0614d6 := allocStructNkDrawVertexLayoutElementMemory(1)
	refeb0614d6 := (*C.struct_nk_draw_vertex_layout_element)(memeb0614d6)
	allocseb0614d6 := new(cgoAllocMap)
	allocseb0614d6.Add(memeb0614d6)

	var cattribute_allocs *cgoAllocMap
	refeb0614d6.attribute, cattribute_allocs = (C.enum_nk_draw_vertex_layout_attribute)(x.Attribute), cgoAllocsUnknown
	allocseb0614d6.Borrow(cattribute_allocs)

	var cformat_allocs *cgoAllocMap
	refeb0614d6.format, cformat_allocs = (C.enum_nk_draw_vertex_layout_format)(x.Format), cgoAllocsUnknown
	allocseb0614d6.Borrow(cformat_allocs)

	var coffset_allocs *cgoAllocMap
	refeb0614d6.offset, coffset_allocs = (C.nk_size)(x.Offset), cgoAllocsUnknown
	allocseb0614d6.Borrow(coffset_allocs)

	x.refeb0614d6 = refeb0614d6
	x.allocseb0614d6 = allocseb0614d6
	return refeb0614d6, allocseb0614d6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DrawVertexLayoutElement) PassValue() (C.struct_nk_draw_vertex_layout_element, *cgoAllocMap) {
	if x.refeb0614d6 != nil {
		return *x.refeb0614d6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DrawVertexLayoutElement) Deref() {
	if x.refeb0614d6 == nil {
		return
	}
	x.Attribute = (DrawVertexLayoutAttribute)(x.refeb0614d6.attribute)
	x.Format = (DrawVertexLayoutFormat)(x.refeb0614d6.format)
	x.Offset = (Size)(x.refeb0614d6.offset)
}

// Ref returns a reference to C object as it is.
func (x *EditState) Ref() *C.struct_nk_edit_state {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_edit_state)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *EditState) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewEditStateRef converts the C object reference into a raw struct reference without wrapping.
func NewEditStateRef(ref unsafe.Pointer) *EditState {
	return (*EditState)(ref)
}

// NewEditState allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewEditState() *EditState {
	return (*EditState)(allocStructNkEditStateMemory(1))
}

// allocStructNkEditStateMemory allocates memory for type C.struct_nk_edit_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkEditStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkEditStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkEditStateValue = unsafe.Sizeof([1]C.struct_nk_edit_state{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *EditState) PassRef() *C.struct_nk_edit_state {
	if x == nil {
		x = (*EditState)(allocStructNkEditStateMemory(1))
	}
	return (*C.struct_nk_edit_state)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Font) Ref() *C.struct_nk_font {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_font)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Font) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFontRef converts the C object reference into a raw struct reference without wrapping.
func NewFontRef(ref unsafe.Pointer) *Font {
	return (*Font)(ref)
}

// NewFont allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFont() *Font {
	return (*Font)(allocStructNkFontMemory(1))
}

// allocStructNkFontMemory allocates memory for type C.struct_nk_font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkFontValue = unsafe.Sizeof([1]C.struct_nk_font{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Font) PassRef() *C.struct_nk_font {
	if x == nil {
		x = (*Font)(allocStructNkFontMemory(1))
	}
	return (*C.struct_nk_font)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FontAtlas) Ref() *C.struct_nk_font_atlas {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_font_atlas)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FontAtlas) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFontAtlasRef converts the C object reference into a raw struct reference without wrapping.
func NewFontAtlasRef(ref unsafe.Pointer) *FontAtlas {
	return (*FontAtlas)(ref)
}

// NewFontAtlas allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFontAtlas() *FontAtlas {
	return (*FontAtlas)(allocStructNkFontAtlasMemory(1))
}

// allocStructNkFontAtlasMemory allocates memory for type C.struct_nk_font_atlas in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkFontAtlasMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkFontAtlasValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkFontAtlasValue = unsafe.Sizeof([1]C.struct_nk_font_atlas{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FontAtlas) PassRef() *C.struct_nk_font_atlas {
	if x == nil {
		x = (*FontAtlas)(allocStructNkFontAtlasMemory(1))
	}
	return (*C.struct_nk_font_atlas)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FontConfig) Ref() *C.struct_nk_font_config {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_font_config)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FontConfig) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFontConfigRef converts the C object reference into a raw struct reference without wrapping.
func NewFontConfigRef(ref unsafe.Pointer) *FontConfig {
	return (*FontConfig)(ref)
}

// NewFontConfig allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFontConfig() *FontConfig {
	return (*FontConfig)(allocStructNkFontConfigMemory(1))
}

// allocStructNkFontConfigMemory allocates memory for type C.struct_nk_font_config in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkFontConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkFontConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkFontConfigValue = unsafe.Sizeof([1]C.struct_nk_font_config{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FontConfig) PassRef() *C.struct_nk_font_config {
	if x == nil {
		x = (*FontConfig)(allocStructNkFontConfigMemory(1))
	}
	return (*C.struct_nk_font_config)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *FontGlyph) Ref() *C.struct_nk_font_glyph {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_font_glyph)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *FontGlyph) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewFontGlyphRef converts the C object reference into a raw struct reference without wrapping.
func NewFontGlyphRef(ref unsafe.Pointer) *FontGlyph {
	return (*FontGlyph)(ref)
}

// NewFontGlyph allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewFontGlyph() *FontGlyph {
	return (*FontGlyph)(allocStructNkFontGlyphMemory(1))
}

// allocStructNkFontGlyphMemory allocates memory for type C.struct_nk_font_glyph in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkFontGlyphMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkFontGlyphValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkFontGlyphValue = unsafe.Sizeof([1]C.struct_nk_font_glyph{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *FontGlyph) PassRef() *C.struct_nk_font_glyph {
	if x == nil {
		x = (*FontGlyph)(allocStructNkFontGlyphMemory(1))
	}
	return (*C.struct_nk_font_glyph)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Image) Ref() *C.struct_nk_image {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_image)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Image) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewImageRef converts the C object reference into a raw struct reference without wrapping.
func NewImageRef(ref unsafe.Pointer) *Image {
	return (*Image)(ref)
}

// NewImage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewImage() *Image {
	return (*Image)(allocStructNkImageMemory(1))
}

// allocStructNkImageMemory allocates memory for type C.struct_nk_image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkImageValue = unsafe.Sizeof([1]C.struct_nk_image{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Image) PassRef() *C.struct_nk_image {
	if x == nil {
		x = (*Image)(allocStructNkImageMemory(1))
	}
	return (*C.struct_nk_image)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Input) Ref() *C.struct_nk_input {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_input)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Input) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewInputRef converts the C object reference into a raw struct reference without wrapping.
func NewInputRef(ref unsafe.Pointer) *Input {
	return (*Input)(ref)
}

// NewInput allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewInput() *Input {
	return (*Input)(allocStructNkInputMemory(1))
}

// allocStructNkInputMemory allocates memory for type C.struct_nk_input in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkInputMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkInputValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkInputValue = unsafe.Sizeof([1]C.struct_nk_input{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Input) PassRef() *C.struct_nk_input {
	if x == nil {
		x = (*Input)(allocStructNkInputMemory(1))
	}
	return (*C.struct_nk_input)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Key) Ref() *C.struct_nk_key {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_key)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Key) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewKeyRef converts the C object reference into a raw struct reference without wrapping.
func NewKeyRef(ref unsafe.Pointer) *Key {
	return (*Key)(ref)
}

// NewKey allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewKey() *Key {
	return (*Key)(allocStructNkKeyMemory(1))
}

// allocStructNkKeyMemory allocates memory for type C.struct_nk_key in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkKeyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkKeyValue = unsafe.Sizeof([1]C.struct_nk_key{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Key) PassRef() *C.struct_nk_key {
	if x == nil {
		x = (*Key)(allocStructNkKeyMemory(1))
	}
	return (*C.struct_nk_key)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Keyboard) Ref() *C.struct_nk_keyboard {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_keyboard)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Keyboard) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewKeyboardRef converts the C object reference into a raw struct reference without wrapping.
func NewKeyboardRef(ref unsafe.Pointer) *Keyboard {
	return (*Keyboard)(ref)
}

// NewKeyboard allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewKeyboard() *Keyboard {
	return (*Keyboard)(allocStructNkKeyboardMemory(1))
}

// allocStructNkKeyboardMemory allocates memory for type C.struct_nk_keyboard in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkKeyboardMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkKeyboardValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkKeyboardValue = unsafe.Sizeof([1]C.struct_nk_keyboard{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Keyboard) PassRef() *C.struct_nk_keyboard {
	if x == nil {
		x = (*Keyboard)(allocStructNkKeyboardMemory(1))
	}
	return (*C.struct_nk_keyboard)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *ListView) Ref() *C.struct_nk_list_view {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_list_view)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *ListView) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewListViewRef converts the C object reference into a raw struct reference without wrapping.
func NewListViewRef(ref unsafe.Pointer) *ListView {
	return (*ListView)(ref)
}

// NewListView allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewListView() *ListView {
	return (*ListView)(allocStructNkListViewMemory(1))
}

// allocStructNkListViewMemory allocates memory for type C.struct_nk_list_view in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkListViewMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkListViewValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkListViewValue = unsafe.Sizeof([1]C.struct_nk_list_view{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *ListView) PassRef() *C.struct_nk_list_view {
	if x == nil {
		x = (*ListView)(allocStructNkListViewMemory(1))
	}
	return (*C.struct_nk_list_view)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Memory) Ref() *C.struct_nk_memory {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_memory)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Memory) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMemoryRef converts the C object reference into a raw struct reference without wrapping.
func NewMemoryRef(ref unsafe.Pointer) *Memory {
	return (*Memory)(ref)
}

// NewMemory allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMemory() *Memory {
	return (*Memory)(allocStructNkMemoryMemory(1))
}

// allocStructNkMemoryMemory allocates memory for type C.struct_nk_memory in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkMemoryMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkMemoryValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkMemoryValue = unsafe.Sizeof([1]C.struct_nk_memory{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Memory) PassRef() *C.struct_nk_memory {
	if x == nil {
		x = (*Memory)(allocStructNkMemoryMemory(1))
	}
	return (*C.struct_nk_memory)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MemoryStatus) Ref() *C.struct_nk_memory_status {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_memory_status)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MemoryStatus) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMemoryStatusRef converts the C object reference into a raw struct reference without wrapping.
func NewMemoryStatusRef(ref unsafe.Pointer) *MemoryStatus {
	return (*MemoryStatus)(ref)
}

// NewMemoryStatus allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMemoryStatus() *MemoryStatus {
	return (*MemoryStatus)(allocStructNkMemoryStatusMemory(1))
}

// allocStructNkMemoryStatusMemory allocates memory for type C.struct_nk_memory_status in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkMemoryStatusMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkMemoryStatusValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkMemoryStatusValue = unsafe.Sizeof([1]C.struct_nk_memory_status{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MemoryStatus) PassRef() *C.struct_nk_memory_status {
	if x == nil {
		x = (*MemoryStatus)(allocStructNkMemoryStatusMemory(1))
	}
	return (*C.struct_nk_memory_status)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MenuState) Ref() *C.struct_nk_menu_state {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_menu_state)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MenuState) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMenuStateRef converts the C object reference into a raw struct reference without wrapping.
func NewMenuStateRef(ref unsafe.Pointer) *MenuState {
	return (*MenuState)(ref)
}

// NewMenuState allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMenuState() *MenuState {
	return (*MenuState)(allocStructNkMenuStateMemory(1))
}

// allocStructNkMenuStateMemory allocates memory for type C.struct_nk_menu_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkMenuStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkMenuStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkMenuStateValue = unsafe.Sizeof([1]C.struct_nk_menu_state{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MenuState) PassRef() *C.struct_nk_menu_state {
	if x == nil {
		x = (*MenuState)(allocStructNkMenuStateMemory(1))
	}
	return (*C.struct_nk_menu_state)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Mouse) Ref() *C.struct_nk_mouse {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_mouse)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Mouse) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMouseRef converts the C object reference into a raw struct reference without wrapping.
func NewMouseRef(ref unsafe.Pointer) *Mouse {
	return (*Mouse)(ref)
}

// NewMouse allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMouse() *Mouse {
	return (*Mouse)(allocStructNkMouseMemory(1))
}

// allocStructNkMouseMemory allocates memory for type C.struct_nk_mouse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkMouseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkMouseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkMouseValue = unsafe.Sizeof([1]C.struct_nk_mouse{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Mouse) PassRef() *C.struct_nk_mouse {
	if x == nil {
		x = (*Mouse)(allocStructNkMouseMemory(1))
	}
	return (*C.struct_nk_mouse)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *MouseButton) Ref() *C.struct_nk_mouse_button {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_mouse_button)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *MouseButton) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMouseButtonRef converts the C object reference into a raw struct reference without wrapping.
func NewMouseButtonRef(ref unsafe.Pointer) *MouseButton {
	return (*MouseButton)(ref)
}

// NewMouseButton allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMouseButton() *MouseButton {
	return (*MouseButton)(allocStructNkMouseButtonMemory(1))
}

// allocStructNkMouseButtonMemory allocates memory for type C.struct_nk_mouse_button in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkMouseButtonMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkMouseButtonValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkMouseButtonValue = unsafe.Sizeof([1]C.struct_nk_mouse_button{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *MouseButton) PassRef() *C.struct_nk_mouse_button {
	if x == nil {
		x = (*MouseButton)(allocStructNkMouseButtonMemory(1))
	}
	return (*C.struct_nk_mouse_button)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Page) Ref() *C.struct_nk_page {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_page)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Page) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPageRef converts the C object reference into a raw struct reference without wrapping.
func NewPageRef(ref unsafe.Pointer) *Page {
	return (*Page)(ref)
}

// NewPage allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPage() *Page {
	return (*Page)(allocStructNkPageMemory(1))
}

// allocStructNkPageMemory allocates memory for type C.struct_nk_page in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPageValue = unsafe.Sizeof([1]C.struct_nk_page{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Page) PassRef() *C.struct_nk_page {
	if x == nil {
		x = (*Page)(allocStructNkPageMemory(1))
	}
	return (*C.struct_nk_page)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PageElement) Ref() *C.struct_nk_page_element {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_page_element)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PageElement) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPageElementRef converts the C object reference into a raw struct reference without wrapping.
func NewPageElementRef(ref unsafe.Pointer) *PageElement {
	return (*PageElement)(ref)
}

// NewPageElement allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPageElement() *PageElement {
	return (*PageElement)(allocStructNkPageElementMemory(1))
}

// allocStructNkPageElementMemory allocates memory for type C.struct_nk_page_element in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPageElementMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPageElementValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPageElementValue = unsafe.Sizeof([1]C.struct_nk_page_element{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PageElement) PassRef() *C.struct_nk_page_element {
	if x == nil {
		x = (*PageElement)(allocStructNkPageElementMemory(1))
	}
	return (*C.struct_nk_page_element)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Panel) Ref() *C.struct_nk_panel {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_panel)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Panel) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPanelRef converts the C object reference into a raw struct reference without wrapping.
func NewPanelRef(ref unsafe.Pointer) *Panel {
	return (*Panel)(ref)
}

// NewPanel allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPanel() *Panel {
	return (*Panel)(allocStructNkPanelMemory(1))
}

// allocStructNkPanelMemory allocates memory for type C.struct_nk_panel in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPanelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPanelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPanelValue = unsafe.Sizeof([1]C.struct_nk_panel{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Panel) PassRef() *C.struct_nk_panel {
	if x == nil {
		x = (*Panel)(allocStructNkPanelMemory(1))
	}
	return (*C.struct_nk_panel)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Pool) Ref() *C.struct_nk_pool {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_pool)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Pool) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPoolRef converts the C object reference into a raw struct reference without wrapping.
func NewPoolRef(ref unsafe.Pointer) *Pool {
	return (*Pool)(ref)
}

// NewPool allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPool() *Pool {
	return (*Pool)(allocStructNkPoolMemory(1))
}

// allocStructNkPoolMemory allocates memory for type C.struct_nk_pool in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPoolMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPoolValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPoolValue = unsafe.Sizeof([1]C.struct_nk_pool{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Pool) PassRef() *C.struct_nk_pool {
	if x == nil {
		x = (*Pool)(allocStructNkPoolMemory(1))
	}
	return (*C.struct_nk_pool)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PopupBuffer) Ref() *C.struct_nk_popup_buffer {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_popup_buffer)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PopupBuffer) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPopupBufferRef converts the C object reference into a raw struct reference without wrapping.
func NewPopupBufferRef(ref unsafe.Pointer) *PopupBuffer {
	return (*PopupBuffer)(ref)
}

// NewPopupBuffer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPopupBuffer() *PopupBuffer {
	return (*PopupBuffer)(allocStructNkPopupBufferMemory(1))
}

// allocStructNkPopupBufferMemory allocates memory for type C.struct_nk_popup_buffer in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPopupBufferMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPopupBufferValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPopupBufferValue = unsafe.Sizeof([1]C.struct_nk_popup_buffer{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PopupBuffer) PassRef() *C.struct_nk_popup_buffer {
	if x == nil {
		x = (*PopupBuffer)(allocStructNkPopupBufferMemory(1))
	}
	return (*C.struct_nk_popup_buffer)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PopupState) Ref() *C.struct_nk_popup_state {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_popup_state)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PopupState) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPopupStateRef converts the C object reference into a raw struct reference without wrapping.
func NewPopupStateRef(ref unsafe.Pointer) *PopupState {
	return (*PopupState)(ref)
}

// NewPopupState allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPopupState() *PopupState {
	return (*PopupState)(allocStructNkPopupStateMemory(1))
}

// allocStructNkPopupStateMemory allocates memory for type C.struct_nk_popup_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPopupStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPopupStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPopupStateValue = unsafe.Sizeof([1]C.struct_nk_popup_state{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PopupState) PassRef() *C.struct_nk_popup_state {
	if x == nil {
		x = (*PopupState)(allocStructNkPopupStateMemory(1))
	}
	return (*C.struct_nk_popup_state)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *PropertyState) Ref() *C.struct_nk_property_state {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_property_state)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *PropertyState) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewPropertyStateRef converts the C object reference into a raw struct reference without wrapping.
func NewPropertyStateRef(ref unsafe.Pointer) *PropertyState {
	return (*PropertyState)(ref)
}

// NewPropertyState allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewPropertyState() *PropertyState {
	return (*PropertyState)(allocStructNkPropertyStateMemory(1))
}

// allocStructNkPropertyStateMemory allocates memory for type C.struct_nk_property_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkPropertyStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkPropertyStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkPropertyStateValue = unsafe.Sizeof([1]C.struct_nk_property_state{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *PropertyState) PassRef() *C.struct_nk_property_state {
	if x == nil {
		x = (*PropertyState)(allocStructNkPropertyStateMemory(1))
	}
	return (*C.struct_nk_property_state)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Rect) Ref() *C.struct_nk_rect {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_rect)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Rect) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRectRef converts the C object reference into a raw struct reference without wrapping.
func NewRectRef(ref unsafe.Pointer) *Rect {
	return (*Rect)(ref)
}

// NewRect allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRect() *Rect {
	return (*Rect)(allocStructNkRectMemory(1))
}

// allocStructNkRectMemory allocates memory for type C.struct_nk_rect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkRectMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkRectValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkRectValue = unsafe.Sizeof([1]C.struct_nk_rect{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Rect) PassRef() *C.struct_nk_rect {
	if x == nil {
		x = (*Rect)(allocStructNkRectMemory(1))
	}
	return (*C.struct_nk_rect)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Recti) Ref() *C.struct_nk_recti {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_recti)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Recti) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRectiRef converts the C object reference into a raw struct reference without wrapping.
func NewRectiRef(ref unsafe.Pointer) *Recti {
	return (*Recti)(ref)
}

// NewRecti allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRecti() *Recti {
	return (*Recti)(allocStructNkRectiMemory(1))
}

// allocStructNkRectiMemory allocates memory for type C.struct_nk_recti in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkRectiMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkRectiValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkRectiValue = unsafe.Sizeof([1]C.struct_nk_recti{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Recti) PassRef() *C.struct_nk_recti {
	if x == nil {
		x = (*Recti)(allocStructNkRectiMemory(1))
	}
	return (*C.struct_nk_recti)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *RowLayout) Ref() *C.struct_nk_row_layout {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_row_layout)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *RowLayout) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewRowLayoutRef converts the C object reference into a raw struct reference without wrapping.
func NewRowLayoutRef(ref unsafe.Pointer) *RowLayout {
	return (*RowLayout)(ref)
}

// NewRowLayout allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewRowLayout() *RowLayout {
	return (*RowLayout)(allocStructNkRowLayoutMemory(1))
}

// allocStructNkRowLayoutMemory allocates memory for type C.struct_nk_row_layout in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkRowLayoutMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkRowLayoutValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkRowLayoutValue = unsafe.Sizeof([1]C.struct_nk_row_layout{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *RowLayout) PassRef() *C.struct_nk_row_layout {
	if x == nil {
		x = (*RowLayout)(allocStructNkRowLayoutMemory(1))
	}
	return (*C.struct_nk_row_layout)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Scroll) Ref() *C.struct_nk_scroll {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_scroll)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Scroll) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewScrollRef converts the C object reference into a raw struct reference without wrapping.
func NewScrollRef(ref unsafe.Pointer) *Scroll {
	return (*Scroll)(ref)
}

// NewScroll allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewScroll() *Scroll {
	return (*Scroll)(allocStructNkScrollMemory(1))
}

// allocStructNkScrollMemory allocates memory for type C.struct_nk_scroll in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkScrollMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkScrollValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkScrollValue = unsafe.Sizeof([1]C.struct_nk_scroll{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Scroll) PassRef() *C.struct_nk_scroll {
	if x == nil {
		x = (*Scroll)(allocStructNkScrollMemory(1))
	}
	return (*C.struct_nk_scroll)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Str) Ref() *C.struct_nk_str {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_str)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Str) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStrRef converts the C object reference into a raw struct reference without wrapping.
func NewStrRef(ref unsafe.Pointer) *Str {
	return (*Str)(ref)
}

// NewStr allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStr() *Str {
	return (*Str)(allocStructNkStrMemory(1))
}

// allocStructNkStrMemory allocates memory for type C.struct_nk_str in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStrMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStrValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStrValue = unsafe.Sizeof([1]C.struct_nk_str{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Str) PassRef() *C.struct_nk_str {
	if x == nil {
		x = (*Str)(allocStructNkStrMemory(1))
	}
	return (*C.struct_nk_str)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Style) Ref() *C.struct_nk_style {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Style) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleRef(ref unsafe.Pointer) *Style {
	return (*Style)(ref)
}

// NewStyle allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyle() *Style {
	return (*Style)(allocStructNkStyleMemory(1))
}

// allocStructNkStyleMemory allocates memory for type C.struct_nk_style in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleValue = unsafe.Sizeof([1]C.struct_nk_style{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Style) PassRef() *C.struct_nk_style {
	if x == nil {
		x = (*Style)(allocStructNkStyleMemory(1))
	}
	return (*C.struct_nk_style)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleButton) Ref() *C.struct_nk_style_button {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_button)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleButton) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleButtonRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleButtonRef(ref unsafe.Pointer) *StyleButton {
	return (*StyleButton)(ref)
}

// NewStyleButton allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleButton() *StyleButton {
	return (*StyleButton)(allocStructNkStyleButtonMemory(1))
}

// allocStructNkStyleButtonMemory allocates memory for type C.struct_nk_style_button in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleButtonMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleButtonValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleButtonValue = unsafe.Sizeof([1]C.struct_nk_style_button{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleButton) PassRef() *C.struct_nk_style_button {
	if x == nil {
		x = (*StyleButton)(allocStructNkStyleButtonMemory(1))
	}
	return (*C.struct_nk_style_button)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleChart) Ref() *C.struct_nk_style_chart {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_chart)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleChart) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleChartRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleChartRef(ref unsafe.Pointer) *StyleChart {
	return (*StyleChart)(ref)
}

// NewStyleChart allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleChart() *StyleChart {
	return (*StyleChart)(allocStructNkStyleChartMemory(1))
}

// allocStructNkStyleChartMemory allocates memory for type C.struct_nk_style_chart in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleChartMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleChartValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleChartValue = unsafe.Sizeof([1]C.struct_nk_style_chart{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleChart) PassRef() *C.struct_nk_style_chart {
	if x == nil {
		x = (*StyleChart)(allocStructNkStyleChartMemory(1))
	}
	return (*C.struct_nk_style_chart)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleCombo) Ref() *C.struct_nk_style_combo {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_combo)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleCombo) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleComboRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleComboRef(ref unsafe.Pointer) *StyleCombo {
	return (*StyleCombo)(ref)
}

// NewStyleCombo allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleCombo() *StyleCombo {
	return (*StyleCombo)(allocStructNkStyleComboMemory(1))
}

// allocStructNkStyleComboMemory allocates memory for type C.struct_nk_style_combo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleComboMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleComboValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleComboValue = unsafe.Sizeof([1]C.struct_nk_style_combo{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleCombo) PassRef() *C.struct_nk_style_combo {
	if x == nil {
		x = (*StyleCombo)(allocStructNkStyleComboMemory(1))
	}
	return (*C.struct_nk_style_combo)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleEdit) Ref() *C.struct_nk_style_edit {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_edit)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleEdit) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleEditRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleEditRef(ref unsafe.Pointer) *StyleEdit {
	return (*StyleEdit)(ref)
}

// NewStyleEdit allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleEdit() *StyleEdit {
	return (*StyleEdit)(allocStructNkStyleEditMemory(1))
}

// allocStructNkStyleEditMemory allocates memory for type C.struct_nk_style_edit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleEditMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleEditValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleEditValue = unsafe.Sizeof([1]C.struct_nk_style_edit{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleEdit) PassRef() *C.struct_nk_style_edit {
	if x == nil {
		x = (*StyleEdit)(allocStructNkStyleEditMemory(1))
	}
	return (*C.struct_nk_style_edit)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleItem) Ref() *C.struct_nk_style_item {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_item)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleItem) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleItemRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleItemRef(ref unsafe.Pointer) *StyleItem {
	return (*StyleItem)(ref)
}

// NewStyleItem allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleItem() *StyleItem {
	return (*StyleItem)(allocStructNkStyleItemMemory(1))
}

// allocStructNkStyleItemMemory allocates memory for type C.struct_nk_style_item in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleItemMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleItemValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleItemValue = unsafe.Sizeof([1]C.struct_nk_style_item{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleItem) PassRef() *C.struct_nk_style_item {
	if x == nil {
		x = (*StyleItem)(allocStructNkStyleItemMemory(1))
	}
	return (*C.struct_nk_style_item)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleProgress) Ref() *C.struct_nk_style_progress {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_progress)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleProgress) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleProgressRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleProgressRef(ref unsafe.Pointer) *StyleProgress {
	return (*StyleProgress)(ref)
}

// NewStyleProgress allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleProgress() *StyleProgress {
	return (*StyleProgress)(allocStructNkStyleProgressMemory(1))
}

// allocStructNkStyleProgressMemory allocates memory for type C.struct_nk_style_progress in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleProgressMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleProgressValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleProgressValue = unsafe.Sizeof([1]C.struct_nk_style_progress{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleProgress) PassRef() *C.struct_nk_style_progress {
	if x == nil {
		x = (*StyleProgress)(allocStructNkStyleProgressMemory(1))
	}
	return (*C.struct_nk_style_progress)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleProperty) Ref() *C.struct_nk_style_property {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_property)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleProperty) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStylePropertyRef converts the C object reference into a raw struct reference without wrapping.
func NewStylePropertyRef(ref unsafe.Pointer) *StyleProperty {
	return (*StyleProperty)(ref)
}

// NewStyleProperty allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleProperty() *StyleProperty {
	return (*StyleProperty)(allocStructNkStylePropertyMemory(1))
}

// allocStructNkStylePropertyMemory allocates memory for type C.struct_nk_style_property in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStylePropertyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStylePropertyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStylePropertyValue = unsafe.Sizeof([1]C.struct_nk_style_property{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleProperty) PassRef() *C.struct_nk_style_property {
	if x == nil {
		x = (*StyleProperty)(allocStructNkStylePropertyMemory(1))
	}
	return (*C.struct_nk_style_property)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleScrollbar) Ref() *C.struct_nk_style_scrollbar {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_scrollbar)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleScrollbar) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleScrollbarRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleScrollbarRef(ref unsafe.Pointer) *StyleScrollbar {
	return (*StyleScrollbar)(ref)
}

// NewStyleScrollbar allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleScrollbar() *StyleScrollbar {
	return (*StyleScrollbar)(allocStructNkStyleScrollbarMemory(1))
}

// allocStructNkStyleScrollbarMemory allocates memory for type C.struct_nk_style_scrollbar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleScrollbarMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleScrollbarValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleScrollbarValue = unsafe.Sizeof([1]C.struct_nk_style_scrollbar{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleScrollbar) PassRef() *C.struct_nk_style_scrollbar {
	if x == nil {
		x = (*StyleScrollbar)(allocStructNkStyleScrollbarMemory(1))
	}
	return (*C.struct_nk_style_scrollbar)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleSelectable) Ref() *C.struct_nk_style_selectable {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_selectable)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleSelectable) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleSelectableRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleSelectableRef(ref unsafe.Pointer) *StyleSelectable {
	return (*StyleSelectable)(ref)
}

// NewStyleSelectable allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleSelectable() *StyleSelectable {
	return (*StyleSelectable)(allocStructNkStyleSelectableMemory(1))
}

// allocStructNkStyleSelectableMemory allocates memory for type C.struct_nk_style_selectable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleSelectableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleSelectableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleSelectableValue = unsafe.Sizeof([1]C.struct_nk_style_selectable{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleSelectable) PassRef() *C.struct_nk_style_selectable {
	if x == nil {
		x = (*StyleSelectable)(allocStructNkStyleSelectableMemory(1))
	}
	return (*C.struct_nk_style_selectable)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleSlide) Ref() *C.struct_nk_style_slide {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_slide)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleSlide) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleSlideRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleSlideRef(ref unsafe.Pointer) *StyleSlide {
	return (*StyleSlide)(ref)
}

// NewStyleSlide allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleSlide() *StyleSlide {
	return (*StyleSlide)(allocStructNkStyleSlideMemory(1))
}

// allocStructNkStyleSlideMemory allocates memory for type C.struct_nk_style_slide in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleSlideMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleSlideValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleSlideValue = unsafe.Sizeof([1]C.struct_nk_style_slide{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleSlide) PassRef() *C.struct_nk_style_slide {
	if x == nil {
		x = (*StyleSlide)(allocStructNkStyleSlideMemory(1))
	}
	return (*C.struct_nk_style_slide)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleSlider) Ref() *C.struct_nk_style_slider {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_slider)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleSlider) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleSliderRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleSliderRef(ref unsafe.Pointer) *StyleSlider {
	return (*StyleSlider)(ref)
}

// NewStyleSlider allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleSlider() *StyleSlider {
	return (*StyleSlider)(allocStructNkStyleSliderMemory(1))
}

// allocStructNkStyleSliderMemory allocates memory for type C.struct_nk_style_slider in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleSliderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleSliderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleSliderValue = unsafe.Sizeof([1]C.struct_nk_style_slider{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleSlider) PassRef() *C.struct_nk_style_slider {
	if x == nil {
		x = (*StyleSlider)(allocStructNkStyleSliderMemory(1))
	}
	return (*C.struct_nk_style_slider)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleTab) Ref() *C.struct_nk_style_tab {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_tab)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleTab) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleTabRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleTabRef(ref unsafe.Pointer) *StyleTab {
	return (*StyleTab)(ref)
}

// NewStyleTab allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleTab() *StyleTab {
	return (*StyleTab)(allocStructNkStyleTabMemory(1))
}

// allocStructNkStyleTabMemory allocates memory for type C.struct_nk_style_tab in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleTabMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleTabValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleTabValue = unsafe.Sizeof([1]C.struct_nk_style_tab{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleTab) PassRef() *C.struct_nk_style_tab {
	if x == nil {
		x = (*StyleTab)(allocStructNkStyleTabMemory(1))
	}
	return (*C.struct_nk_style_tab)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleText) Ref() *C.struct_nk_style_text {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_text)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleText) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleTextRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleTextRef(ref unsafe.Pointer) *StyleText {
	return (*StyleText)(ref)
}

// NewStyleText allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleText() *StyleText {
	return (*StyleText)(allocStructNkStyleTextMemory(1))
}

// allocStructNkStyleTextMemory allocates memory for type C.struct_nk_style_text in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleTextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleTextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleTextValue = unsafe.Sizeof([1]C.struct_nk_style_text{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleText) PassRef() *C.struct_nk_style_text {
	if x == nil {
		x = (*StyleText)(allocStructNkStyleTextMemory(1))
	}
	return (*C.struct_nk_style_text)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleToggle) Ref() *C.struct_nk_style_toggle {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_toggle)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleToggle) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleToggleRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleToggleRef(ref unsafe.Pointer) *StyleToggle {
	return (*StyleToggle)(ref)
}

// NewStyleToggle allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleToggle() *StyleToggle {
	return (*StyleToggle)(allocStructNkStyleToggleMemory(1))
}

// allocStructNkStyleToggleMemory allocates memory for type C.struct_nk_style_toggle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleToggleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleToggleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleToggleValue = unsafe.Sizeof([1]C.struct_nk_style_toggle{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleToggle) PassRef() *C.struct_nk_style_toggle {
	if x == nil {
		x = (*StyleToggle)(allocStructNkStyleToggleMemory(1))
	}
	return (*C.struct_nk_style_toggle)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleWindow) Ref() *C.struct_nk_style_window {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_window)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleWindow) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleWindowRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleWindowRef(ref unsafe.Pointer) *StyleWindow {
	return (*StyleWindow)(ref)
}

// NewStyleWindow allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleWindow() *StyleWindow {
	return (*StyleWindow)(allocStructNkStyleWindowMemory(1))
}

// allocStructNkStyleWindowMemory allocates memory for type C.struct_nk_style_window in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleWindowMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleWindowValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleWindowValue = unsafe.Sizeof([1]C.struct_nk_style_window{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleWindow) PassRef() *C.struct_nk_style_window {
	if x == nil {
		x = (*StyleWindow)(allocStructNkStyleWindowMemory(1))
	}
	return (*C.struct_nk_style_window)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *StyleWindowHeader) Ref() *C.struct_nk_style_window_header {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_style_window_header)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *StyleWindowHeader) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewStyleWindowHeaderRef converts the C object reference into a raw struct reference without wrapping.
func NewStyleWindowHeaderRef(ref unsafe.Pointer) *StyleWindowHeader {
	return (*StyleWindowHeader)(ref)
}

// NewStyleWindowHeader allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewStyleWindowHeader() *StyleWindowHeader {
	return (*StyleWindowHeader)(allocStructNkStyleWindowHeaderMemory(1))
}

// allocStructNkStyleWindowHeaderMemory allocates memory for type C.struct_nk_style_window_header in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkStyleWindowHeaderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkStyleWindowHeaderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkStyleWindowHeaderValue = unsafe.Sizeof([1]C.struct_nk_style_window_header{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *StyleWindowHeader) PassRef() *C.struct_nk_style_window_header {
	if x == nil {
		x = (*StyleWindowHeader)(allocStructNkStyleWindowHeaderMemory(1))
	}
	return (*C.struct_nk_style_window_header)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Table) Ref() *C.struct_nk_table {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_table)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Table) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTableRef converts the C object reference into a raw struct reference without wrapping.
func NewTableRef(ref unsafe.Pointer) *Table {
	return (*Table)(ref)
}

// NewTable allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTable() *Table {
	return (*Table)(allocStructNkTableMemory(1))
}

// allocStructNkTableMemory allocates memory for type C.struct_nk_table in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkTableMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkTableValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkTableValue = unsafe.Sizeof([1]C.struct_nk_table{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Table) PassRef() *C.struct_nk_table {
	if x == nil {
		x = (*Table)(allocStructNkTableMemory(1))
	}
	return (*C.struct_nk_table)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TextEdit) Ref() *C.struct_nk_text_edit {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_text_edit)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TextEdit) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTextEditRef converts the C object reference into a raw struct reference without wrapping.
func NewTextEditRef(ref unsafe.Pointer) *TextEdit {
	return (*TextEdit)(ref)
}

// NewTextEdit allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTextEdit() *TextEdit {
	return (*TextEdit)(allocStructNkTextEditMemory(1))
}

// allocStructNkTextEditMemory allocates memory for type C.struct_nk_text_edit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkTextEditMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkTextEditValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkTextEditValue = unsafe.Sizeof([1]C.struct_nk_text_edit{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TextEdit) PassRef() *C.struct_nk_text_edit {
	if x == nil {
		x = (*TextEdit)(allocStructNkTextEditMemory(1))
	}
	return (*C.struct_nk_text_edit)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TextUndoRecord) Ref() *C.struct_nk_text_undo_record {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_text_undo_record)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TextUndoRecord) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTextUndoRecordRef converts the C object reference into a raw struct reference without wrapping.
func NewTextUndoRecordRef(ref unsafe.Pointer) *TextUndoRecord {
	return (*TextUndoRecord)(ref)
}

// NewTextUndoRecord allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTextUndoRecord() *TextUndoRecord {
	return (*TextUndoRecord)(allocStructNkTextUndoRecordMemory(1))
}

// allocStructNkTextUndoRecordMemory allocates memory for type C.struct_nk_text_undo_record in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkTextUndoRecordMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkTextUndoRecordValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkTextUndoRecordValue = unsafe.Sizeof([1]C.struct_nk_text_undo_record{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TextUndoRecord) PassRef() *C.struct_nk_text_undo_record {
	if x == nil {
		x = (*TextUndoRecord)(allocStructNkTextUndoRecordMemory(1))
	}
	return (*C.struct_nk_text_undo_record)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *TextUndoState) Ref() *C.struct_nk_text_undo_state {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_text_undo_state)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *TextUndoState) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewTextUndoStateRef converts the C object reference into a raw struct reference without wrapping.
func NewTextUndoStateRef(ref unsafe.Pointer) *TextUndoState {
	return (*TextUndoState)(ref)
}

// NewTextUndoState allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewTextUndoState() *TextUndoState {
	return (*TextUndoState)(allocStructNkTextUndoStateMemory(1))
}

// allocStructNkTextUndoStateMemory allocates memory for type C.struct_nk_text_undo_state in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkTextUndoStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkTextUndoStateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkTextUndoStateValue = unsafe.Sizeof([1]C.struct_nk_text_undo_state{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *TextUndoState) PassRef() *C.struct_nk_text_undo_state {
	if x == nil {
		x = (*TextUndoState)(allocStructNkTextUndoStateMemory(1))
	}
	return (*C.struct_nk_text_undo_state)(unsafe.Pointer(x))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UserFont) Ref() *C.struct_nk_user_font {
	if x == nil {
		return nil
	}
	return x.ref738ce62e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UserFont) Free() {
	if x != nil && x.allocs738ce62e != nil {
		x.allocs738ce62e.(*cgoAllocMap).Free()
		x.ref738ce62e = nil
	}
}

// NewUserFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUserFontRef(ref unsafe.Pointer) *UserFont {
	if ref == nil {
		return nil
	}
	obj := new(UserFont)
	obj.ref738ce62e = (*C.struct_nk_user_font)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UserFont) PassRef() (*C.struct_nk_user_font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref738ce62e != nil {
		return x.ref738ce62e, nil
	}
	mem738ce62e := allocStructNkUserFontMemory(1)
	ref738ce62e := (*C.struct_nk_user_font)(mem738ce62e)
	allocs738ce62e := new(cgoAllocMap)
	allocs738ce62e.Add(mem738ce62e)

	var cuserdata_allocs *cgoAllocMap
	ref738ce62e.userdata, cuserdata_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Userdata)), cgoAllocsUnknown
	allocs738ce62e.Borrow(cuserdata_allocs)

	var cheight_allocs *cgoAllocMap
	ref738ce62e.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocs738ce62e.Borrow(cheight_allocs)

	var cwidth_allocs *cgoAllocMap
	ref738ce62e.width, cwidth_allocs = x.Width.PassValue()
	allocs738ce62e.Borrow(cwidth_allocs)

	var cquery_allocs *cgoAllocMap
	ref738ce62e.query, cquery_allocs = x.Query.PassValue()
	allocs738ce62e.Borrow(cquery_allocs)

	var ctexture_allocs *cgoAllocMap
	ref738ce62e.texture, ctexture_allocs = *(*C.nk_handle)(unsafe.Pointer(&x.Texture)), cgoAllocsUnknown
	allocs738ce62e.Borrow(ctexture_allocs)

	x.ref738ce62e = ref738ce62e
	x.allocs738ce62e = allocs738ce62e
	return ref738ce62e, allocs738ce62e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UserFont) PassValue() (C.struct_nk_user_font, *cgoAllocMap) {
	if x.ref738ce62e != nil {
		return *x.ref738ce62e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UserFont) Deref() {
	if x.ref738ce62e == nil {
		return
	}
	x.Userdata = *(*Handle)(unsafe.Pointer(&x.ref738ce62e.userdata))
	x.Height = (float32)(x.ref738ce62e.height)
	x.Width = *NewTextWidthFRef(unsafe.Pointer(&x.ref738ce62e.width))
	x.Query = *NewQueryFontGlyphFRef(unsafe.Pointer(&x.ref738ce62e.query))
	x.Texture = *(*Handle)(unsafe.Pointer(&x.ref738ce62e.texture))
}

// allocStructNkUserFontGlyphMemory allocates memory for type C.struct_nk_user_font_glyph in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkUserFontGlyphMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkUserFontGlyphValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkUserFontGlyphValue = unsafe.Sizeof([1]C.struct_nk_user_font_glyph{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UserFontGlyph) Ref() *C.struct_nk_user_font_glyph {
	if x == nil {
		return nil
	}
	return x.ref4a84b297
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UserFontGlyph) Free() {
	if x != nil && x.allocs4a84b297 != nil {
		x.allocs4a84b297.(*cgoAllocMap).Free()
		x.ref4a84b297 = nil
	}
}

// NewUserFontGlyphRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUserFontGlyphRef(ref unsafe.Pointer) *UserFontGlyph {
	if ref == nil {
		return nil
	}
	obj := new(UserFontGlyph)
	obj.ref4a84b297 = (*C.struct_nk_user_font_glyph)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UserFontGlyph) PassRef() (*C.struct_nk_user_font_glyph, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4a84b297 != nil {
		return x.ref4a84b297, nil
	}
	mem4a84b297 := allocStructNkUserFontGlyphMemory(1)
	ref4a84b297 := (*C.struct_nk_user_font_glyph)(mem4a84b297)
	allocs4a84b297 := new(cgoAllocMap)
	allocs4a84b297.Add(mem4a84b297)

	var cuv_allocs *cgoAllocMap
	ref4a84b297.uv, cuv_allocs = *(*[2]C.struct_nk_vec2)(unsafe.Pointer(&x.Uv)), cgoAllocsUnknown
	allocs4a84b297.Borrow(cuv_allocs)

	var coffset_allocs *cgoAllocMap
	ref4a84b297.offset, coffset_allocs = *(*C.struct_nk_vec2)(unsafe.Pointer(&x.Offset)), cgoAllocsUnknown
	allocs4a84b297.Borrow(coffset_allocs)

	var cwidth_allocs *cgoAllocMap
	ref4a84b297.width, cwidth_allocs = (C.float)(x.Width), cgoAllocsUnknown
	allocs4a84b297.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref4a84b297.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocs4a84b297.Borrow(cheight_allocs)

	var cxadvance_allocs *cgoAllocMap
	ref4a84b297.xadvance, cxadvance_allocs = (C.float)(x.Xadvance), cgoAllocsUnknown
	allocs4a84b297.Borrow(cxadvance_allocs)

	x.ref4a84b297 = ref4a84b297
	x.allocs4a84b297 = allocs4a84b297
	return ref4a84b297, allocs4a84b297

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UserFontGlyph) PassValue() (C.struct_nk_user_font_glyph, *cgoAllocMap) {
	if x.ref4a84b297 != nil {
		return *x.ref4a84b297, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UserFontGlyph) Deref() {
	if x.ref4a84b297 == nil {
		return
	}
	x.Uv = *(*[2]Vec2)(unsafe.Pointer(&x.ref4a84b297.uv))
	x.Offset = *(*Vec2)(unsafe.Pointer(&x.ref4a84b297.offset))
	x.Width = (float32)(x.ref4a84b297.width)
	x.Height = (float32)(x.ref4a84b297.height)
	x.Xadvance = (float32)(x.ref4a84b297.xadvance)
}

// Ref returns a reference to C object as it is.
func (x *Vec2) Ref() *C.struct_nk_vec2 {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_vec2)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Vec2) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewVec2Ref converts the C object reference into a raw struct reference without wrapping.
func NewVec2Ref(ref unsafe.Pointer) *Vec2 {
	return (*Vec2)(ref)
}

// NewVec2 allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewVec2() *Vec2 {
	return (*Vec2)(allocStructNkVec2Memory(1))
}

// allocStructNkVec2Memory allocates memory for type C.struct_nk_vec2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkVec2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkVec2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkVec2Value = unsafe.Sizeof([1]C.struct_nk_vec2{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Vec2) PassRef() *C.struct_nk_vec2 {
	if x == nil {
		x = (*Vec2)(allocStructNkVec2Memory(1))
	}
	return (*C.struct_nk_vec2)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Vec2i) Ref() *C.struct_nk_vec2i {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_vec2i)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Vec2i) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewVec2iRef converts the C object reference into a raw struct reference without wrapping.
func NewVec2iRef(ref unsafe.Pointer) *Vec2i {
	return (*Vec2i)(ref)
}

// NewVec2i allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewVec2i() *Vec2i {
	return (*Vec2i)(allocStructNkVec2iMemory(1))
}

// allocStructNkVec2iMemory allocates memory for type C.struct_nk_vec2i in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkVec2iMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkVec2iValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkVec2iValue = unsafe.Sizeof([1]C.struct_nk_vec2i{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Vec2i) PassRef() *C.struct_nk_vec2i {
	if x == nil {
		x = (*Vec2i)(allocStructNkVec2iMemory(1))
	}
	return (*C.struct_nk_vec2i)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Window) Ref() *C.struct_nk_window {
	if x == nil {
		return nil
	}
	return (*C.struct_nk_window)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Window) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewWindowRef converts the C object reference into a raw struct reference without wrapping.
func NewWindowRef(ref unsafe.Pointer) *Window {
	return (*Window)(ref)
}

// NewWindow allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewWindow() *Window {
	return (*Window)(allocStructNkWindowMemory(1))
}

// allocStructNkWindowMemory allocates memory for type C.struct_nk_window in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStructNkWindowMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStructNkWindowValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStructNkWindowValue = unsafe.Sizeof([1]C.struct_nk_window{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Window) PassRef() *C.struct_nk_window {
	if x == nil {
		x = (*Window)(allocStructNkWindowMemory(1))
	}
	return (*C.struct_nk_window)(unsafe.Pointer(x))
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(unsafe.Pointer(h.Data))
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// unpackPByteString represents the data from Go string as *C.nk_byte and avoids copying.
func unpackPByteString(str string) (*C.nk_byte, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.nk_byte)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

// unpackArgSUserFont transforms a sliced Go data structure into plain C format.
func unpackArgSUserFont(x []UserFont) (unpacked *C.struct_nk_user_font, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_nk_user_font) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStructNkUserFontMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: uintptr(mem0),
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_nk_user_font)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_nk_user_font)(unsafe.Pointer(h.Data))
	return
}
